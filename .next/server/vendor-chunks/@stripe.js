"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stripe";
exports.ids = ["vendor-chunks/@stripe"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressElement: () => (/* binding */ AddressElement),\n/* harmony export */   AffirmMessageElement: () => (/* binding */ AffirmMessageElement),\n/* harmony export */   AfterpayClearpayMessageElement: () => (/* binding */ AfterpayClearpayMessageElement),\n/* harmony export */   AuBankAccountElement: () => (/* binding */ AuBankAccountElement),\n/* harmony export */   CardCvcElement: () => (/* binding */ CardCvcElement),\n/* harmony export */   CardElement: () => (/* binding */ CardElement),\n/* harmony export */   CardExpiryElement: () => (/* binding */ CardExpiryElement),\n/* harmony export */   CardNumberElement: () => (/* binding */ CardNumberElement),\n/* harmony export */   CartElement: () => (/* binding */ CartElement),\n/* harmony export */   Elements: () => (/* binding */ Elements),\n/* harmony export */   ElementsConsumer: () => (/* binding */ ElementsConsumer),\n/* harmony export */   EpsBankElement: () => (/* binding */ EpsBankElement),\n/* harmony export */   FpxBankElement: () => (/* binding */ FpxBankElement),\n/* harmony export */   IbanElement: () => (/* binding */ IbanElement),\n/* harmony export */   IdealBankElement: () => (/* binding */ IdealBankElement),\n/* harmony export */   LinkAuthenticationElement: () => (/* binding */ LinkAuthenticationElement),\n/* harmony export */   P24BankElement: () => (/* binding */ P24BankElement),\n/* harmony export */   PayButtonElement: () => (/* binding */ PayButtonElement),\n/* harmony export */   PaymentElement: () => (/* binding */ PaymentElement),\n/* harmony export */   PaymentMethodMessagingElement: () => (/* binding */ PaymentMethodMessagingElement),\n/* harmony export */   PaymentRequestButtonElement: () => (/* binding */ PaymentRequestButtonElement),\n/* harmony export */   ShippingAddressElement: () => (/* binding */ ShippingAddressElement),\n/* harmony export */   useCartElement: () => (/* binding */ useCartElement),\n/* harmony export */   useCartElementState: () => (/* binding */ useCartElementState),\n/* harmony export */   useElements: () => (/* binding */ useElements),\n/* harmony export */   useStripe: () => (/* binding */ useStripe)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar usePrevious = function usePrevious(value) {\n    var ref = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(value);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref.current;\n};\nvar isUnknownObject = function isUnknownObject(raw) {\n    return raw !== null && _typeof(raw) === \"object\";\n};\nvar isPromise = function isPromise(raw) {\n    return isUnknownObject(raw) && typeof raw.then === \"function\";\n}; // We are using types to enforce the `stripe` prop in this lib,\n// but in an untyped integration `stripe` could be anything, so we need\n// to do some sanity validation to prevent type errors.\nvar isStripe = function isStripe(raw) {\n    return isUnknownObject(raw) && typeof raw.elements === \"function\" && typeof raw.createToken === \"function\" && typeof raw.createPaymentMethod === \"function\" && typeof raw.confirmCardPayment === \"function\";\n};\nvar PLAIN_OBJECT_STR = \"[object Object]\";\nvar isEqual = function isEqual(left, right) {\n    if (!isUnknownObject(left) || !isUnknownObject(right)) {\n        return left === right;\n    }\n    var leftArray = Array.isArray(left);\n    var rightArray = Array.isArray(right);\n    if (leftArray !== rightArray) return false;\n    var leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;\n    var rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;\n    if (leftPlainObject !== rightPlainObject) return false; // not sure what sort of special object this is (regexp is one option), so\n    // fallback to reference check.\n    if (!leftPlainObject && !leftArray) return left === right;\n    var leftKeys = Object.keys(left);\n    var rightKeys = Object.keys(right);\n    if (leftKeys.length !== rightKeys.length) return false;\n    var keySet = {};\n    for(var i = 0; i < leftKeys.length; i += 1){\n        keySet[leftKeys[i]] = true;\n    }\n    for(var _i = 0; _i < rightKeys.length; _i += 1){\n        keySet[rightKeys[_i]] = true;\n    }\n    var allKeys = Object.keys(keySet);\n    if (allKeys.length !== leftKeys.length) {\n        return false;\n    }\n    var l = left;\n    var r = right;\n    var pred = function pred(key) {\n        return isEqual(l[key], r[key]);\n    };\n    return allKeys.every(pred);\n};\nvar extractAllowedOptionsUpdates = function extractAllowedOptionsUpdates(options, prevOptions, immutableKeys) {\n    if (!isUnknownObject(options)) {\n        return null;\n    }\n    return Object.keys(options).reduce(function(newOptions, key) {\n        var isUpdated = !isUnknownObject(prevOptions) || !isEqual(options[key], prevOptions[key]);\n        if (immutableKeys.includes(key)) {\n            if (isUpdated) {\n                console.warn(\"Unsupported prop change: options.\".concat(key, \" is not a mutable property.\"));\n            }\n            return newOptions;\n        }\n        if (!isUpdated) {\n            return newOptions;\n        }\n        return _objectSpread2(_objectSpread2({}, newOptions || {}), {}, _defineProperty({}, key, options[key]));\n    }, null);\n};\nvar INVALID_STRIPE_ERROR = \"Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\"; // We are using types to enforce the `stripe` prop in this lib, but in a real\n// integration `stripe` could be anything, so we need to do some sanity\n// validation to prevent type errors.\nvar validateStripe = function validateStripe(maybeStripe) {\n    if (maybeStripe === null || isStripe(maybeStripe)) {\n        return maybeStripe;\n    }\n    throw new Error(INVALID_STRIPE_ERROR);\n};\nvar parseStripeProp = function parseStripeProp(raw) {\n    if (isPromise(raw)) {\n        return {\n            tag: \"async\",\n            stripePromise: Promise.resolve(raw).then(validateStripe)\n        };\n    }\n    var stripe = validateStripe(raw);\n    if (stripe === null) {\n        return {\n            tag: \"empty\"\n        };\n    }\n    return {\n        tag: \"sync\",\n        stripe: stripe\n    };\n};\nvar ElementsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nElementsContext.displayName = \"ElementsContext\";\nvar parseElementsContext = function parseElementsContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n    }\n    return ctx;\n};\nvar CartElementContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nCartElementContext.displayName = \"CartElementContext\";\nvar parseCartElementContext = function parseCartElementContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n    }\n    return ctx;\n};\n/**\n * The `Elements` provider allows you to use [Element components](https://stripe.com/docs/stripe-js/react#element-components) and access the [Stripe object](https://stripe.com/docs/js/initializing) in any nested component.\n * Render an `Elements` provider at the root of your React app so that it is available everywhere you need it.\n *\n * To use the `Elements` provider, call `loadStripe` from `@stripe/stripe-js` with your publishable key.\n * The `loadStripe` function will asynchronously load the Stripe.js script and initialize a `Stripe` object.\n * Pass the returned `Promise` to `Elements`.\n *\n * @docs https://stripe.com/docs/stripe-js/react#elements-provider\n */ var Elements = function Elements(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return parseStripeProp(rawStripeProp);\n    }, [\n        rawStripeProp\n    ]);\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), cart = _React$useState2[0], setCart = _React$useState2[1];\n    var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), cartState = _React$useState4[0], setCartState = _React$useState4[1]; // For a sync stripe instance, initialize into context\n    var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0___default().useState(function() {\n        return {\n            stripe: parsed.tag === \"sync\" ? parsed.stripe : null,\n            elements: parsed.tag === \"sync\" ? parsed.stripe.elements(options) : null\n        };\n    }), _React$useState6 = _slicedToArray(_React$useState5, 2), ctx = _React$useState6[0], setContext = _React$useState6[1];\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var isMounted = true;\n        var safeSetContext = function safeSetContext(stripe) {\n            setContext(function(ctx) {\n                // no-op if we already have a stripe instance (https://github.com/stripe/react-stripe-js/issues/296)\n                if (ctx.stripe) return ctx;\n                return {\n                    stripe: stripe,\n                    elements: stripe.elements(options)\n                };\n            });\n        }; // For an async stripePromise, store it in context once resolved\n        if (parsed.tag === \"async\" && !ctx.stripe) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe && isMounted) {\n                    // Only update Elements context if the component is still mounted\n                    // and stripe is not null. We allow stripe to be null to make\n                    // handling SSR easier.\n                    safeSetContext(stripe);\n                }\n            });\n        } else if (parsed.tag === \"sync\" && !ctx.stripe) {\n            // Or, handle a sync stripe instance going from null -> populated\n            safeSetContext(parsed.stripe);\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed,\n        ctx,\n        options\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Apply updates to elements when options prop has relevant changes\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (!ctx.elements) {\n            return;\n        }\n        var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n            \"clientSecret\",\n            \"fonts\"\n        ]);\n        if (updates) {\n            ctx.elements.update(updates);\n        }\n    }, [\n        options,\n        prevOptions,\n        ctx.elements\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var anyStripe = ctx.stripe;\n        if (!anyStripe || !anyStripe._registerWrapper || !anyStripe.registerAppInfo) {\n            return;\n        }\n        anyStripe._registerWrapper({\n            name: \"react-stripe-js\",\n            version: \"1.16.5\"\n        });\n        anyStripe.registerAppInfo({\n            name: \"react-stripe-js\",\n            version: \"1.16.5\",\n            url: \"https://stripe.com/docs/stripe-js/react\"\n        });\n    }, [\n        ctx.stripe\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ElementsContext.Provider, {\n        value: ctx\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CartElementContext.Provider, {\n        value: {\n            cart: cart,\n            setCart: setCart,\n            cartState: cartState,\n            setCartState: setCartState\n        }\n    }, children));\n};\nElements.propTypes = {\n    stripe: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().any),\n    options: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)\n};\nvar useElementsContextWithUseCase = function useElementsContextWithUseCase(useCaseMessage) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(ElementsContext);\n    return parseElementsContext(ctx, useCaseMessage);\n};\nvar useCartElementContextWithUseCase = function useCartElementContextWithUseCase(useCaseMessage) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(CartElementContext);\n    return parseCartElementContext(ctx, useCaseMessage);\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#useelements-hook\n */ var useElements = function useElements() {\n    var _useElementsContextWi = useElementsContextWithUseCase(\"calls useElements()\"), elements = _useElementsContextWi.elements;\n    return elements;\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#usestripe-hook\n */ var useStripe = function useStripe() {\n    var _useElementsContextWi2 = useElementsContextWithUseCase(\"calls useStripe()\"), stripe = _useElementsContextWi2.stripe;\n    return stripe;\n};\n/**\n * @docs https://stripe.com/docs/payments/checkout/cart-element\n */ var useCartElement = function useCartElement() {\n    var _useCartElementContex = useCartElementContextWithUseCase(\"calls useCartElement()\"), cart = _useCartElementContex.cart;\n    return cart;\n};\n/**\n * @docs https://stripe.com/docs/payments/checkout/cart-element\n */ var useCartElementState = function useCartElementState() {\n    var _useCartElementContex2 = useCartElementContextWithUseCase(\"calls useCartElementState()\"), cartState = _useCartElementContex2.cartState;\n    return cartState;\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#elements-consumer\n */ var ElementsConsumer = function ElementsConsumer(_ref2) {\n    var children = _ref2.children;\n    var ctx = useElementsContextWithUseCase(\"mounts <ElementsConsumer>\"); // Assert to satisfy the busted React.FC return type (it should be ReactNode)\n    return children(ctx);\n};\nElementsConsumer.propTypes = {\n    children: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func).isRequired\n};\nvar useAttachEvent = function useAttachEvent(element, event, cb) {\n    var cbDefined = !!cb;\n    var cbRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(cb); // In many integrations the callback prop changes on each render.\n    // Using a ref saves us from calling element.on/.off every render.\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        cbRef.current = cb;\n    }, [\n        cb\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (!cbDefined || !element) {\n            return function() {};\n        }\n        var decoratedCb = function decoratedCb() {\n            if (cbRef.current) {\n                cbRef.current.apply(cbRef, arguments);\n            }\n        };\n        element.on(event, decoratedCb);\n        return function() {\n            element.off(event, decoratedCb);\n        };\n    }, [\n        cbDefined,\n        event,\n        element,\n        cbRef\n    ]);\n};\nvar capitalized = function capitalized(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nvar createElementComponent = function createElementComponent(type, isServer) {\n    var displayName = \"\".concat(capitalized(type), \"Element\");\n    var ClientElement = function ClientElement(_ref) {\n        var id = _ref.id, className = _ref.className, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, onBlur = _ref.onBlur, onFocus = _ref.onFocus, onReady = _ref.onReady, onChange = _ref.onChange, onEscape = _ref.onEscape, onClick = _ref.onClick, onLoadError = _ref.onLoadError, onLoaderStart = _ref.onLoaderStart, onNetworksChange = _ref.onNetworksChange, onCheckout = _ref.onCheckout, onLineItemClick = _ref.onLineItemClick, onConfirm = _ref.onConfirm, onCancel = _ref.onCancel, onShippingAddressChange = _ref.onShippingAddressChange, onShippingRateChange = _ref.onShippingRateChange;\n        var _useElementsContextWi = useElementsContextWithUseCase(\"mounts <\".concat(displayName, \">\")), elements = _useElementsContextWi.elements;\n        var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), element = _React$useState2[0], setElement = _React$useState2[1];\n        var elementRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n        var domNode = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n        var _useCartElementContex = useCartElementContextWithUseCase(\"mounts <\".concat(displayName, \">\")), setCart = _useCartElementContex.setCart, setCartState = _useCartElementContex.setCartState; // For every event where the merchant provides a callback, call element.on\n        // with that callback. If the merchant ever changes the callback, removes\n        // the old callback with element.off and then call element.on with the new one.\n        useAttachEvent(element, \"blur\", onBlur);\n        useAttachEvent(element, \"focus\", onFocus);\n        useAttachEvent(element, \"escape\", onEscape);\n        useAttachEvent(element, \"click\", onClick);\n        useAttachEvent(element, \"loaderror\", onLoadError);\n        useAttachEvent(element, \"loaderstart\", onLoaderStart);\n        useAttachEvent(element, \"networkschange\", onNetworksChange);\n        useAttachEvent(element, \"lineitemclick\", onLineItemClick);\n        useAttachEvent(element, \"confirm\", onConfirm);\n        useAttachEvent(element, \"cancel\", onCancel);\n        useAttachEvent(element, \"shippingaddresschange\", onShippingAddressChange);\n        useAttachEvent(element, \"shippingratechange\", onShippingRateChange);\n        var readyCallback;\n        if (type === \"cart\") {\n            readyCallback = function readyCallback(event) {\n                setCartState(event);\n                onReady && onReady(event);\n            };\n        } else if (onReady) {\n            if (type === \"payButton\") {\n                // Passes through the event, which includes visible PM types\n                readyCallback = onReady;\n            } else {\n                // For other Elements, pass through the Element itself.\n                readyCallback = function readyCallback() {\n                    onReady(element);\n                };\n            }\n        }\n        useAttachEvent(element, \"ready\", readyCallback);\n        var changeCallback = type === \"cart\" ? function(event) {\n            setCartState(event);\n            onChange && onChange(event);\n        } : onChange;\n        useAttachEvent(element, \"change\", changeCallback);\n        var checkoutCallback = type === \"cart\" ? function(event) {\n            setCartState(event);\n            onCheckout && onCheckout(event);\n        } : onCheckout;\n        useAttachEvent(element, \"checkout\", checkoutCallback);\n        react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect(function() {\n            if (elementRef.current === null && elements && domNode.current !== null) {\n                var newElement = elements.create(type, options);\n                if (type === \"cart\" && setCart) {\n                    // we know that elements.create return value must be of type StripeCartElement if type is 'cart',\n                    // we need to cast because typescript is not able to infer which overloaded method is used based off param type\n                    setCart(newElement);\n                } // Store element in a ref to ensure it's _immediately_ available in cleanup hooks in StrictMode\n                elementRef.current = newElement; // Store element in state to facilitate event listener attachment\n                setElement(newElement);\n                newElement.mount(domNode.current);\n            }\n        }, [\n            elements,\n            options,\n            setCart\n        ]);\n        var prevOptions = usePrevious(options);\n        react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n            if (!elementRef.current) {\n                return;\n            }\n            var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n                \"paymentRequest\"\n            ]);\n            if (updates) {\n                elementRef.current.update(updates);\n            }\n        }, [\n            options,\n            prevOptions\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect(function() {\n            return function() {\n                if (elementRef.current) {\n                    elementRef.current.destroy();\n                    elementRef.current = null;\n                }\n            };\n        }, []);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            id: id,\n            className: className,\n            ref: domNode\n        });\n    }; // Only render the Element wrapper in a server environment.\n    var ServerElement = function ServerElement(props) {\n        // Validate that we are in the right context by calling useElementsContextWithUseCase.\n        useElementsContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        useCartElementContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        var id = props.id, className = props.className;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            id: id,\n            className: className\n        });\n    };\n    var Element = isServer ? ServerElement : ClientElement;\n    Element.propTypes = {\n        id: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n        className: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n        onChange: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onBlur: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onFocus: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onReady: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onEscape: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onClick: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onLoadError: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onLoaderStart: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onNetworksChange: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onCheckout: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onLineItemClick: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onConfirm: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onCancel: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onShippingAddressChange: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onShippingRateChange: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        options: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)\n    };\n    Element.displayName = displayName;\n    Element.__elementType = type;\n    return Element;\n};\nvar isServer = \"undefined\" === \"undefined\";\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AuBankAccountElement = createElementComponent(\"auBankAccount\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardElement = createElementComponent(\"card\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardNumberElement = createElementComponent(\"cardNumber\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardExpiryElement = createElementComponent(\"cardExpiry\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardCvcElement = createElementComponent(\"cardCvc\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var FpxBankElement = createElementComponent(\"fpxBank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IbanElement = createElementComponent(\"iban\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IdealBankElement = createElementComponent(\"idealBank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var P24BankElement = createElementComponent(\"p24Bank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var EpsBankElement = createElementComponent(\"epsBank\", isServer);\nvar PaymentElement = createElementComponent(\"payment\", isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PayButtonElement = createElementComponent(\"payButton\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentRequestButtonElement = createElementComponent(\"paymentRequestButton\", isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var LinkAuthenticationElement = createElementComponent(\"linkAuthentication\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AddressElement = createElementComponent(\"address\", isServer);\n/**\n * @deprecated\n * Use `AddressElement` instead.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var ShippingAddressElement = createElementComponent(\"shippingAddress\", isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/elements/cart-element\n */ var CartElement = createElementComponent(\"cart\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentMethodMessagingElement = createElementComponent(\"paymentMethodMessaging\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AffirmMessageElement = createElementComponent(\"affirmMessage\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AfterpayClearpayMessageElement = createElementComponent(\"afterpayClearpayMessage\", isServer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvZGlzdC9yZWFjdC1zdHJpcGUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUNTO0FBRW5DLFNBQVNFLFFBQVFDLE1BQU0sRUFBRUMsY0FBYztJQUNyQyxJQUFJQyxPQUFPQyxPQUFPRCxJQUFJLENBQUNGO0lBRXZCLElBQUlHLE9BQU9DLHFCQUFxQixFQUFFO1FBQ2hDLElBQUlDLFVBQVVGLE9BQU9DLHFCQUFxQixDQUFDSjtRQUUzQyxJQUFJQyxnQkFBZ0I7WUFDbEJJLFVBQVVBLFFBQVFDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHO2dCQUNwQyxPQUFPSixPQUFPSyx3QkFBd0IsQ0FBQ1IsUUFBUU8sS0FBS0UsVUFBVTtZQUNoRTtRQUNGO1FBRUFQLEtBQUtRLElBQUksQ0FBQ0MsS0FBSyxDQUFDVCxNQUFNRztJQUN4QjtJQUVBLE9BQU9IO0FBQ1Q7QUFFQSxTQUFTVSxlQUFlQyxNQUFNO0lBQzVCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7UUFDekMsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFLElBQUksT0FBT0MsU0FBUyxDQUFDRCxFQUFFLEdBQUcsQ0FBQztRQUVwRCxJQUFJQSxJQUFJLEdBQUc7WUFDVGYsUUFBUUksT0FBT2MsU0FBUyxNQUFNQyxPQUFPLENBQUMsU0FBVUMsR0FBRztnQkFDakRDLGdCQUFnQlAsUUFBUU0sS0FBS0YsTUFBTSxDQUFDRSxJQUFJO1lBQzFDO1FBQ0YsT0FBTyxJQUFJaEIsT0FBT2tCLHlCQUF5QixFQUFFO1lBQzNDbEIsT0FBT21CLGdCQUFnQixDQUFDVCxRQUFRVixPQUFPa0IseUJBQXlCLENBQUNKO1FBQ25FLE9BQU87WUFDTGxCLFFBQVFJLE9BQU9jLFNBQVNDLE9BQU8sQ0FBQyxTQUFVQyxHQUFHO2dCQUMzQ2hCLE9BQU9vQixj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LHVCQUF1QixjQUFjRTtBQUM3RDs7Q0FFQyxHQUVELElBQUl1QyxvQkFBb0J6Qyx1QkFBdUIsY0FBY0U7QUFDN0Q7O0NBRUMsR0FFRCxJQUFJd0MsaUJBQWlCMUMsdUJBQXVCLFdBQVdFO0FBQ3ZEOztDQUVDLEdBRUQsSUFBSXlDLGlCQUFpQjNDLHVCQUF1QixXQUFXRTtBQUN2RDs7Q0FFQyxHQUVELElBQUkwQyxjQUFjNUMsdUJBQXVCLFFBQVFFO0FBQ2pEOztDQUVDLEdBRUQsSUFBSTJDLG1CQUFtQjdDLHVCQUF1QixhQUFhRTtBQUMzRDs7Q0FFQyxHQUVELElBQUk0QyxpQkFBaUI5Qyx1QkFBdUIsV0FBV0U7QUFDdkQ7O0NBRUMsR0FFRCxJQUFJNkMsaUJBQWlCL0MsdUJBQXVCLFdBQVdFO0FBQ3ZELElBQUk4QyxpQkFBaUJoRCx1QkFBdUIsV0FBV0U7QUFDdkQ7Ozs7O0NBS0MsR0FFRCxJQUFJK0MsbUJBQW1CakQsdUJBQXVCLGFBQWFFO0FBQzNEOztDQUVDLEdBRUQsSUFBSWdELDhCQUE4QmxELHVCQUF1Qix3QkFBd0JFO0FBQ2pGOzs7OztDQUtDLEdBRUQsSUFBSWlELDRCQUE0Qm5ELHVCQUF1QixzQkFBc0JFO0FBQzdFOztDQUVDLEdBRUQsSUFBSWtELGlCQUFpQnBELHVCQUF1QixXQUFXRTtBQUN2RDs7Ozs7Q0FLQyxHQUVELElBQUltRCx5QkFBeUJyRCx1QkFBdUIsbUJBQW1CRTtBQUN2RTs7Ozs7Q0FLQyxHQUVELElBQUlvRCxjQUFjdEQsdUJBQXVCLFFBQVFFO0FBQ2pEOztDQUVDLEdBRUQsSUFBSXFELGdDQUFnQ3ZELHVCQUF1QiwwQkFBMEJFO0FBQ3JGOztDQUVDLEdBRUQsSUFBSXNELHVCQUF1QnhELHVCQUF1QixpQkFBaUJFO0FBQ25FOztDQUVDLEdBRUQsSUFBSXVELGlDQUFpQ3pELHVCQUF1QiwyQkFBMkJFO0FBRXdaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BzdHJpcGUvcmVhY3Qtc3RyaXBlLWpzL2Rpc3QvcmVhY3Qtc3RyaXBlLmVzbS5qcz9iNWViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG5cbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHtcbiAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgJiYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXSk7XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIHVzZVByZXZpb3VzID0gZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUpIHtcbiAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiByZWYuY3VycmVudDtcbn07XG5cbnZhciBpc1Vua25vd25PYmplY3QgPSBmdW5jdGlvbiBpc1Vua25vd25PYmplY3QocmF3KSB7XG4gIHJldHVybiByYXcgIT09IG51bGwgJiYgX3R5cGVvZihyYXcpID09PSAnb2JqZWN0Jztcbn07XG52YXIgaXNQcm9taXNlID0gZnVuY3Rpb24gaXNQcm9taXNlKHJhdykge1xuICByZXR1cm4gaXNVbmtub3duT2JqZWN0KHJhdykgJiYgdHlwZW9mIHJhdy50aGVuID09PSAnZnVuY3Rpb24nO1xufTsgLy8gV2UgYXJlIHVzaW5nIHR5cGVzIHRvIGVuZm9yY2UgdGhlIGBzdHJpcGVgIHByb3AgaW4gdGhpcyBsaWIsXG4vLyBidXQgaW4gYW4gdW50eXBlZCBpbnRlZ3JhdGlvbiBgc3RyaXBlYCBjb3VsZCBiZSBhbnl0aGluZywgc28gd2UgbmVlZFxuLy8gdG8gZG8gc29tZSBzYW5pdHkgdmFsaWRhdGlvbiB0byBwcmV2ZW50IHR5cGUgZXJyb3JzLlxuXG52YXIgaXNTdHJpcGUgPSBmdW5jdGlvbiBpc1N0cmlwZShyYXcpIHtcbiAgcmV0dXJuIGlzVW5rbm93bk9iamVjdChyYXcpICYmIHR5cGVvZiByYXcuZWxlbWVudHMgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJhdy5jcmVhdGVUb2tlbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmF3LmNyZWF0ZVBheW1lbnRNZXRob2QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJhdy5jb25maXJtQ2FyZFBheW1lbnQgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgUExBSU5fT0JKRUNUX1NUUiA9ICdbb2JqZWN0IE9iamVjdF0nO1xudmFyIGlzRXF1YWwgPSBmdW5jdGlvbiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gIGlmICghaXNVbmtub3duT2JqZWN0KGxlZnQpIHx8ICFpc1Vua25vd25PYmplY3QocmlnaHQpKSB7XG4gICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xuICB9XG5cbiAgdmFyIGxlZnRBcnJheSA9IEFycmF5LmlzQXJyYXkobGVmdCk7XG4gIHZhciByaWdodEFycmF5ID0gQXJyYXkuaXNBcnJheShyaWdodCk7XG4gIGlmIChsZWZ0QXJyYXkgIT09IHJpZ2h0QXJyYXkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGxlZnRQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChsZWZ0KSA9PT0gUExBSU5fT0JKRUNUX1NUUjtcbiAgdmFyIHJpZ2h0UGxhaW5PYmplY3QgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmlnaHQpID09PSBQTEFJTl9PQkpFQ1RfU1RSO1xuICBpZiAobGVmdFBsYWluT2JqZWN0ICE9PSByaWdodFBsYWluT2JqZWN0KSByZXR1cm4gZmFsc2U7IC8vIG5vdCBzdXJlIHdoYXQgc29ydCBvZiBzcGVjaWFsIG9iamVjdCB0aGlzIGlzIChyZWdleHAgaXMgb25lIG9wdGlvbiksIHNvXG4gIC8vIGZhbGxiYWNrIHRvIHJlZmVyZW5jZSBjaGVjay5cblxuICBpZiAoIWxlZnRQbGFpbk9iamVjdCAmJiAhbGVmdEFycmF5KSByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIHZhciBsZWZ0S2V5cyA9IE9iamVjdC5rZXlzKGxlZnQpO1xuICB2YXIgcmlnaHRLZXlzID0gT2JqZWN0LmtleXMocmlnaHQpO1xuICBpZiAobGVmdEtleXMubGVuZ3RoICE9PSByaWdodEtleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHZhciBrZXlTZXQgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZnRLZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAga2V5U2V0W2xlZnRLZXlzW2ldXSA9IHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcmlnaHRLZXlzLmxlbmd0aDsgX2kgKz0gMSkge1xuICAgIGtleVNldFtyaWdodEtleXNbX2ldXSA9IHRydWU7XG4gIH1cblxuICB2YXIgYWxsS2V5cyA9IE9iamVjdC5rZXlzKGtleVNldCk7XG5cbiAgaWYgKGFsbEtleXMubGVuZ3RoICE9PSBsZWZ0S2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbCA9IGxlZnQ7XG4gIHZhciByID0gcmlnaHQ7XG5cbiAgdmFyIHByZWQgPSBmdW5jdGlvbiBwcmVkKGtleSkge1xuICAgIHJldHVybiBpc0VxdWFsKGxba2V5XSwgcltrZXldKTtcbiAgfTtcblxuICByZXR1cm4gYWxsS2V5cy5ldmVyeShwcmVkKTtcbn07XG5cbnZhciBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzID0gZnVuY3Rpb24gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgaW1tdXRhYmxlS2V5cykge1xuICBpZiAoIWlzVW5rbm93bk9iamVjdChvcHRpb25zKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9wdGlvbnMpLnJlZHVjZShmdW5jdGlvbiAobmV3T3B0aW9ucywga2V5KSB7XG4gICAgdmFyIGlzVXBkYXRlZCA9ICFpc1Vua25vd25PYmplY3QocHJldk9wdGlvbnMpIHx8ICFpc0VxdWFsKG9wdGlvbnNba2V5XSwgcHJldk9wdGlvbnNba2V5XSk7XG5cbiAgICBpZiAoaW1tdXRhYmxlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBpZiAoaXNVcGRhdGVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIHByb3AgY2hhbmdlOiBvcHRpb25zLlwiLmNvbmNhdChrZXksIFwiIGlzIG5vdCBhIG11dGFibGUgcHJvcGVydHkuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKCFpc1VwZGF0ZWQpIHtcbiAgICAgIHJldHVybiBuZXdPcHRpb25zO1xuICAgIH1cblxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgbmV3T3B0aW9ucyB8fCB7fSksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgb3B0aW9uc1trZXldKSk7XG4gIH0sIG51bGwpO1xufTtcblxudmFyIElOVkFMSURfU1RSSVBFX0VSUk9SID0gJ0ludmFsaWQgcHJvcCBgc3RyaXBlYCBzdXBwbGllZCB0byBgRWxlbWVudHNgLiBXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBsb2FkU3RyaXBlYCB1dGlsaXR5IGZyb20gYEBzdHJpcGUvc3RyaXBlLWpzYC4gU2VlIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1wcm9wcy1zdHJpcGUgZm9yIGRldGFpbHMuJzsgLy8gV2UgYXJlIHVzaW5nIHR5cGVzIHRvIGVuZm9yY2UgdGhlIGBzdHJpcGVgIHByb3AgaW4gdGhpcyBsaWIsIGJ1dCBpbiBhIHJlYWxcbi8vIGludGVncmF0aW9uIGBzdHJpcGVgIGNvdWxkIGJlIGFueXRoaW5nLCBzbyB3ZSBuZWVkIHRvIGRvIHNvbWUgc2FuaXR5XG4vLyB2YWxpZGF0aW9uIHRvIHByZXZlbnQgdHlwZSBlcnJvcnMuXG5cbnZhciB2YWxpZGF0ZVN0cmlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaXBlKG1heWJlU3RyaXBlKSB7XG4gIGlmIChtYXliZVN0cmlwZSA9PT0gbnVsbCB8fCBpc1N0cmlwZShtYXliZVN0cmlwZSkpIHtcbiAgICByZXR1cm4gbWF5YmVTdHJpcGU7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9TVFJJUEVfRVJST1IpO1xufTtcblxudmFyIHBhcnNlU3RyaXBlUHJvcCA9IGZ1bmN0aW9uIHBhcnNlU3RyaXBlUHJvcChyYXcpIHtcbiAgaWYgKGlzUHJvbWlzZShyYXcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZzogJ2FzeW5jJyxcbiAgICAgIHN0cmlwZVByb21pc2U6IFByb21pc2UucmVzb2x2ZShyYXcpLnRoZW4odmFsaWRhdGVTdHJpcGUpXG4gICAgfTtcbiAgfVxuXG4gIHZhciBzdHJpcGUgPSB2YWxpZGF0ZVN0cmlwZShyYXcpO1xuXG4gIGlmIChzdHJpcGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnOiAnZW1wdHknXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGFnOiAnc3luYycsXG4gICAgc3RyaXBlOiBzdHJpcGVcbiAgfTtcbn07XG5cbnZhciBFbGVtZW50c0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkVsZW1lbnRzQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdFbGVtZW50c0NvbnRleHQnO1xudmFyIHBhcnNlRWxlbWVudHNDb250ZXh0ID0gZnVuY3Rpb24gcGFyc2VFbGVtZW50c0NvbnRleHQoY3R4LCB1c2VDYXNlKSB7XG4gIGlmICghY3R4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgRWxlbWVudHMgY29udGV4dDsgWW91IG5lZWQgdG8gd3JhcCB0aGUgcGFydCBvZiB5b3VyIGFwcCB0aGF0IFwiLmNvbmNhdCh1c2VDYXNlLCBcIiBpbiBhbiA8RWxlbWVudHM+IHByb3ZpZGVyLlwiKSk7XG4gIH1cblxuICByZXR1cm4gY3R4O1xufTtcbnZhciBDYXJ0RWxlbWVudENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkNhcnRFbGVtZW50Q29udGV4dC5kaXNwbGF5TmFtZSA9ICdDYXJ0RWxlbWVudENvbnRleHQnO1xudmFyIHBhcnNlQ2FydEVsZW1lbnRDb250ZXh0ID0gZnVuY3Rpb24gcGFyc2VDYXJ0RWxlbWVudENvbnRleHQoY3R4LCB1c2VDYXNlKSB7XG4gIGlmICghY3R4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgRWxlbWVudHMgY29udGV4dDsgWW91IG5lZWQgdG8gd3JhcCB0aGUgcGFydCBvZiB5b3VyIGFwcCB0aGF0IFwiLmNvbmNhdCh1c2VDYXNlLCBcIiBpbiBhbiA8RWxlbWVudHM+IHByb3ZpZGVyLlwiKSk7XG4gIH1cblxuICByZXR1cm4gY3R4O1xufTtcbi8qKlxuICogVGhlIGBFbGVtZW50c2AgcHJvdmlkZXIgYWxsb3dzIHlvdSB0byB1c2UgW0VsZW1lbnQgY29tcG9uZW50c10oaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50cykgYW5kIGFjY2VzcyB0aGUgW1N0cmlwZSBvYmplY3RdKGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL2pzL2luaXRpYWxpemluZykgaW4gYW55IG5lc3RlZCBjb21wb25lbnQuXG4gKiBSZW5kZXIgYW4gYEVsZW1lbnRzYCBwcm92aWRlciBhdCB0aGUgcm9vdCBvZiB5b3VyIFJlYWN0IGFwcCBzbyB0aGF0IGl0IGlzIGF2YWlsYWJsZSBldmVyeXdoZXJlIHlvdSBuZWVkIGl0LlxuICpcbiAqIFRvIHVzZSB0aGUgYEVsZW1lbnRzYCBwcm92aWRlciwgY2FsbCBgbG9hZFN0cmlwZWAgZnJvbSBgQHN0cmlwZS9zdHJpcGUtanNgIHdpdGggeW91ciBwdWJsaXNoYWJsZSBrZXkuXG4gKiBUaGUgYGxvYWRTdHJpcGVgIGZ1bmN0aW9uIHdpbGwgYXN5bmNocm9ub3VzbHkgbG9hZCB0aGUgU3RyaXBlLmpzIHNjcmlwdCBhbmQgaW5pdGlhbGl6ZSBhIGBTdHJpcGVgIG9iamVjdC5cbiAqIFBhc3MgdGhlIHJldHVybmVkIGBQcm9taXNlYCB0byBgRWxlbWVudHNgLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1wcm92aWRlclxuICovXG5cbnZhciBFbGVtZW50cyA9IGZ1bmN0aW9uIEVsZW1lbnRzKF9yZWYpIHtcbiAgdmFyIHJhd1N0cmlwZVByb3AgPSBfcmVmLnN0cmlwZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHZhciBwYXJzZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VTdHJpcGVQcm9wKHJhd1N0cmlwZVByb3ApO1xuICB9LCBbcmF3U3RyaXBlUHJvcF0pO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShudWxsKSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgICAgY2FydCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRDYXJ0ID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMyA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlNCA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZTMsIDIpLFxuICAgICAgY2FydFN0YXRlID0gX1JlYWN0JHVzZVN0YXRlNFswXSxcbiAgICAgIHNldENhcnRTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZTRbMV07IC8vIEZvciBhIHN5bmMgc3RyaXBlIGluc3RhbmNlLCBpbml0aWFsaXplIGludG8gY29udGV4dFxuXG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTUgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmlwZTogcGFyc2VkLnRhZyA9PT0gJ3N5bmMnID8gcGFyc2VkLnN0cmlwZSA6IG51bGwsXG4gICAgICBlbGVtZW50czogcGFyc2VkLnRhZyA9PT0gJ3N5bmMnID8gcGFyc2VkLnN0cmlwZS5lbGVtZW50cyhvcHRpb25zKSA6IG51bGxcbiAgICB9O1xuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTYgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGU1LCAyKSxcbiAgICAgIGN0eCA9IF9SZWFjdCR1c2VTdGF0ZTZbMF0sXG4gICAgICBzZXRDb250ZXh0ID0gX1JlYWN0JHVzZVN0YXRlNlsxXTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpc01vdW50ZWQgPSB0cnVlO1xuXG4gICAgdmFyIHNhZmVTZXRDb250ZXh0ID0gZnVuY3Rpb24gc2FmZVNldENvbnRleHQoc3RyaXBlKSB7XG4gICAgICBzZXRDb250ZXh0KGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgLy8gbm8tb3AgaWYgd2UgYWxyZWFkeSBoYXZlIGEgc3RyaXBlIGluc3RhbmNlIChodHRwczovL2dpdGh1Yi5jb20vc3RyaXBlL3JlYWN0LXN0cmlwZS1qcy9pc3N1ZXMvMjk2KVxuICAgICAgICBpZiAoY3R4LnN0cmlwZSkgcmV0dXJuIGN0eDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHJpcGU6IHN0cmlwZSxcbiAgICAgICAgICBlbGVtZW50czogc3RyaXBlLmVsZW1lbnRzKG9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9OyAvLyBGb3IgYW4gYXN5bmMgc3RyaXBlUHJvbWlzZSwgc3RvcmUgaXQgaW4gY29udGV4dCBvbmNlIHJlc29sdmVkXG5cblxuICAgIGlmIChwYXJzZWQudGFnID09PSAnYXN5bmMnICYmICFjdHguc3RyaXBlKSB7XG4gICAgICBwYXJzZWQuc3RyaXBlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzdHJpcGUpIHtcbiAgICAgICAgaWYgKHN0cmlwZSAmJiBpc01vdW50ZWQpIHtcbiAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBFbGVtZW50cyBjb250ZXh0IGlmIHRoZSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZFxuICAgICAgICAgIC8vIGFuZCBzdHJpcGUgaXMgbm90IG51bGwuIFdlIGFsbG93IHN0cmlwZSB0byBiZSBudWxsIHRvIG1ha2VcbiAgICAgICAgICAvLyBoYW5kbGluZyBTU1IgZWFzaWVyLlxuICAgICAgICAgIHNhZmVTZXRDb250ZXh0KHN0cmlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnRhZyA9PT0gJ3N5bmMnICYmICFjdHguc3RyaXBlKSB7XG4gICAgICAvLyBPciwgaGFuZGxlIGEgc3luYyBzdHJpcGUgaW5zdGFuY2UgZ29pbmcgZnJvbSBudWxsIC0+IHBvcHVsYXRlZFxuICAgICAgc2FmZVNldENvbnRleHQocGFyc2VkLnN0cmlwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtwYXJzZWQsIGN0eCwgb3B0aW9uc10pOyAvLyBXYXJuIG9uIGNoYW5nZXMgdG8gc3RyaXBlIHByb3BcblxuICB2YXIgcHJldlN0cmlwZSA9IHVzZVByZXZpb3VzKHJhd1N0cmlwZVByb3ApO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcmV2U3RyaXBlICE9PSBudWxsICYmIHByZXZTdHJpcGUgIT09IHJhd1N0cmlwZVByb3ApIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRWxlbWVudHM6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBgc3RyaXBlYCBwcm9wIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuICB9LCBbcHJldlN0cmlwZSwgcmF3U3RyaXBlUHJvcF0pOyAvLyBBcHBseSB1cGRhdGVzIHRvIGVsZW1lbnRzIHdoZW4gb3B0aW9ucyBwcm9wIGhhcyByZWxldmFudCBjaGFuZ2VzXG5cbiAgdmFyIHByZXZPcHRpb25zID0gdXNlUHJldmlvdXMob3B0aW9ucyk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjdHguZWxlbWVudHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlcyA9IGV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMob3B0aW9ucywgcHJldk9wdGlvbnMsIFsnY2xpZW50U2VjcmV0JywgJ2ZvbnRzJ10pO1xuXG4gICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgIGN0eC5lbGVtZW50cy51cGRhdGUodXBkYXRlcyk7XG4gICAgfVxuICB9LCBbb3B0aW9ucywgcHJldk9wdGlvbnMsIGN0eC5lbGVtZW50c10pOyAvLyBBdHRhY2ggcmVhY3Qtc3RyaXBlLWpzIHZlcnNpb24gdG8gc3RyaXBlLmpzIGluc3RhbmNlXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYW55U3RyaXBlID0gY3R4LnN0cmlwZTtcblxuICAgIGlmICghYW55U3RyaXBlIHx8ICFhbnlTdHJpcGUuX3JlZ2lzdGVyV3JhcHBlciB8fCAhYW55U3RyaXBlLnJlZ2lzdGVyQXBwSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFueVN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyKHtcbiAgICAgIG5hbWU6ICdyZWFjdC1zdHJpcGUtanMnLFxuICAgICAgdmVyc2lvbjogXCIxLjE2LjVcIlxuICAgIH0pO1xuXG4gICAgYW55U3RyaXBlLnJlZ2lzdGVyQXBwSW5mbyh7XG4gICAgICBuYW1lOiAncmVhY3Qtc3RyaXBlLWpzJyxcbiAgICAgIHZlcnNpb246IFwiMS4xNi41XCIsXG4gICAgICB1cmw6ICdodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QnXG4gICAgfSk7XG4gIH0sIFtjdHguc3RyaXBlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbGVtZW50c0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY3R4XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENhcnRFbGVtZW50Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBjYXJ0OiBjYXJ0LFxuICAgICAgc2V0Q2FydDogc2V0Q2FydCxcbiAgICAgIGNhcnRTdGF0ZTogY2FydFN0YXRlLFxuICAgICAgc2V0Q2FydFN0YXRlOiBzZXRDYXJ0U3RhdGVcbiAgICB9XG4gIH0sIGNoaWxkcmVuKSk7XG59O1xuRWxlbWVudHMucHJvcFR5cGVzID0ge1xuICBzdHJpcGU6IFByb3BUeXBlcy5hbnksXG4gIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3Rcbn07XG52YXIgdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UgPSBmdW5jdGlvbiB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZSh1c2VDYXNlTWVzc2FnZSkge1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChFbGVtZW50c0NvbnRleHQpO1xuICByZXR1cm4gcGFyc2VFbGVtZW50c0NvbnRleHQoY3R4LCB1c2VDYXNlTWVzc2FnZSk7XG59O1xudmFyIHVzZUNhcnRFbGVtZW50Q29udGV4dFdpdGhVc2VDYXNlID0gZnVuY3Rpb24gdXNlQ2FydEVsZW1lbnRDb250ZXh0V2l0aFVzZUNhc2UodXNlQ2FzZU1lc3NhZ2UpIHtcbiAgdmFyIGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoQ2FydEVsZW1lbnRDb250ZXh0KTtcbiAgcmV0dXJuIHBhcnNlQ2FydEVsZW1lbnRDb250ZXh0KGN0eCwgdXNlQ2FzZU1lc3NhZ2UpO1xufTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I3VzZWVsZW1lbnRzLWhvb2tcbiAqL1xuXG52YXIgdXNlRWxlbWVudHMgPSBmdW5jdGlvbiB1c2VFbGVtZW50cygpIHtcbiAgdmFyIF91c2VFbGVtZW50c0NvbnRleHRXaSA9IHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlKCdjYWxscyB1c2VFbGVtZW50cygpJyksXG4gICAgICBlbGVtZW50cyA9IF91c2VFbGVtZW50c0NvbnRleHRXaS5lbGVtZW50cztcblxuICByZXR1cm4gZWxlbWVudHM7XG59O1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjdXNlc3RyaXBlLWhvb2tcbiAqL1xuXG52YXIgdXNlU3RyaXBlID0gZnVuY3Rpb24gdXNlU3RyaXBlKCkge1xuICB2YXIgX3VzZUVsZW1lbnRzQ29udGV4dFdpMiA9IHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlKCdjYWxscyB1c2VTdHJpcGUoKScpLFxuICAgICAgc3RyaXBlID0gX3VzZUVsZW1lbnRzQ29udGV4dFdpMi5zdHJpcGU7XG5cbiAgcmV0dXJuIHN0cmlwZTtcbn07XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3BheW1lbnRzL2NoZWNrb3V0L2NhcnQtZWxlbWVudFxuICovXG5cbnZhciB1c2VDYXJ0RWxlbWVudCA9IGZ1bmN0aW9uIHVzZUNhcnRFbGVtZW50KCkge1xuICB2YXIgX3VzZUNhcnRFbGVtZW50Q29udGV4ID0gdXNlQ2FydEVsZW1lbnRDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZUNhcnRFbGVtZW50KCknKSxcbiAgICAgIGNhcnQgPSBfdXNlQ2FydEVsZW1lbnRDb250ZXguY2FydDtcblxuICByZXR1cm4gY2FydDtcbn07XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3BheW1lbnRzL2NoZWNrb3V0L2NhcnQtZWxlbWVudFxuICovXG5cbnZhciB1c2VDYXJ0RWxlbWVudFN0YXRlID0gZnVuY3Rpb24gdXNlQ2FydEVsZW1lbnRTdGF0ZSgpIHtcbiAgdmFyIF91c2VDYXJ0RWxlbWVudENvbnRleDIgPSB1c2VDYXJ0RWxlbWVudENvbnRleHRXaXRoVXNlQ2FzZSgnY2FsbHMgdXNlQ2FydEVsZW1lbnRTdGF0ZSgpJyksXG4gICAgICBjYXJ0U3RhdGUgPSBfdXNlQ2FydEVsZW1lbnRDb250ZXgyLmNhcnRTdGF0ZTtcblxuICByZXR1cm4gY2FydFN0YXRlO1xufTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLWNvbnN1bWVyXG4gKi9cblxudmFyIEVsZW1lbnRzQ29uc3VtZXIgPSBmdW5jdGlvbiBFbGVtZW50c0NvbnN1bWVyKF9yZWYyKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuO1xuICB2YXIgY3R4ID0gdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UoJ21vdW50cyA8RWxlbWVudHNDb25zdW1lcj4nKTsgLy8gQXNzZXJ0IHRvIHNhdGlzZnkgdGhlIGJ1c3RlZCBSZWFjdC5GQyByZXR1cm4gdHlwZSAoaXQgc2hvdWxkIGJlIFJlYWN0Tm9kZSlcblxuICByZXR1cm4gY2hpbGRyZW4oY3R4KTtcbn07XG5FbGVtZW50c0NvbnN1bWVyLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn07XG5cbnZhciB1c2VBdHRhY2hFdmVudCA9IGZ1bmN0aW9uIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsIGV2ZW50LCBjYikge1xuICB2YXIgY2JEZWZpbmVkID0gISFjYjtcbiAgdmFyIGNiUmVmID0gUmVhY3QudXNlUmVmKGNiKTsgLy8gSW4gbWFueSBpbnRlZ3JhdGlvbnMgdGhlIGNhbGxiYWNrIHByb3AgY2hhbmdlcyBvbiBlYWNoIHJlbmRlci5cbiAgLy8gVXNpbmcgYSByZWYgc2F2ZXMgdXMgZnJvbSBjYWxsaW5nIGVsZW1lbnQub24vLm9mZiBldmVyeSByZW5kZXIuXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBjYlJlZi5jdXJyZW50ID0gY2I7XG4gIH0sIFtjYl0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2JEZWZpbmVkIHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgfVxuXG4gICAgdmFyIGRlY29yYXRlZENiID0gZnVuY3Rpb24gZGVjb3JhdGVkQ2IoKSB7XG4gICAgICBpZiAoY2JSZWYuY3VycmVudCkge1xuICAgICAgICBjYlJlZi5jdXJyZW50LmFwcGx5KGNiUmVmLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlbGVtZW50Lm9uKGV2ZW50LCBkZWNvcmF0ZWRDYik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQub2ZmKGV2ZW50LCBkZWNvcmF0ZWRDYik7XG4gICAgfTtcbiAgfSwgW2NiRGVmaW5lZCwgZXZlbnQsIGVsZW1lbnQsIGNiUmVmXSk7XG59O1xuXG52YXIgY2FwaXRhbGl6ZWQgPSBmdW5jdGlvbiBjYXBpdGFsaXplZChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5cbnZhciBjcmVhdGVFbGVtZW50Q29tcG9uZW50ID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudENvbXBvbmVudCh0eXBlLCBpc1NlcnZlcikge1xuICB2YXIgZGlzcGxheU5hbWUgPSBcIlwiLmNvbmNhdChjYXBpdGFsaXplZCh0eXBlKSwgXCJFbGVtZW50XCIpO1xuXG4gIHZhciBDbGllbnRFbGVtZW50ID0gZnVuY3Rpb24gQ2xpZW50RWxlbWVudChfcmVmKSB7XG4gICAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICAgIF9yZWYkb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG9wdGlvbnMsXG4gICAgICAgIG9uQmx1ciA9IF9yZWYub25CbHVyLFxuICAgICAgICBvbkZvY3VzID0gX3JlZi5vbkZvY3VzLFxuICAgICAgICBvblJlYWR5ID0gX3JlZi5vblJlYWR5LFxuICAgICAgICBvbkNoYW5nZSA9IF9yZWYub25DaGFuZ2UsXG4gICAgICAgIG9uRXNjYXBlID0gX3JlZi5vbkVzY2FwZSxcbiAgICAgICAgb25DbGljayA9IF9yZWYub25DbGljayxcbiAgICAgICAgb25Mb2FkRXJyb3IgPSBfcmVmLm9uTG9hZEVycm9yLFxuICAgICAgICBvbkxvYWRlclN0YXJ0ID0gX3JlZi5vbkxvYWRlclN0YXJ0LFxuICAgICAgICBvbk5ldHdvcmtzQ2hhbmdlID0gX3JlZi5vbk5ldHdvcmtzQ2hhbmdlLFxuICAgICAgICBvbkNoZWNrb3V0ID0gX3JlZi5vbkNoZWNrb3V0LFxuICAgICAgICBvbkxpbmVJdGVtQ2xpY2sgPSBfcmVmLm9uTGluZUl0ZW1DbGljayxcbiAgICAgICAgb25Db25maXJtID0gX3JlZi5vbkNvbmZpcm0sXG4gICAgICAgIG9uQ2FuY2VsID0gX3JlZi5vbkNhbmNlbCxcbiAgICAgICAgb25TaGlwcGluZ0FkZHJlc3NDaGFuZ2UgPSBfcmVmLm9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlLFxuICAgICAgICBvblNoaXBwaW5nUmF0ZUNoYW5nZSA9IF9yZWYub25TaGlwcGluZ1JhdGVDaGFuZ2U7XG5cbiAgICB2YXIgX3VzZUVsZW1lbnRzQ29udGV4dFdpID0gdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UoXCJtb3VudHMgPFwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCI+XCIpKSxcbiAgICAgICAgZWxlbWVudHMgPSBfdXNlRWxlbWVudHNDb250ZXh0V2kuZWxlbWVudHM7XG5cbiAgICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUobnVsbCksXG4gICAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgICAgICBlbGVtZW50ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgICAgc2V0RWxlbWVudCA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgICB2YXIgZWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICB2YXIgZG9tTm9kZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcblxuICAgIHZhciBfdXNlQ2FydEVsZW1lbnRDb250ZXggPSB1c2VDYXJ0RWxlbWVudENvbnRleHRXaXRoVXNlQ2FzZShcIm1vdW50cyA8XCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIj5cIikpLFxuICAgICAgICBzZXRDYXJ0ID0gX3VzZUNhcnRFbGVtZW50Q29udGV4LnNldENhcnQsXG4gICAgICAgIHNldENhcnRTdGF0ZSA9IF91c2VDYXJ0RWxlbWVudENvbnRleC5zZXRDYXJ0U3RhdGU7IC8vIEZvciBldmVyeSBldmVudCB3aGVyZSB0aGUgbWVyY2hhbnQgcHJvdmlkZXMgYSBjYWxsYmFjaywgY2FsbCBlbGVtZW50Lm9uXG4gICAgLy8gd2l0aCB0aGF0IGNhbGxiYWNrLiBJZiB0aGUgbWVyY2hhbnQgZXZlciBjaGFuZ2VzIHRoZSBjYWxsYmFjaywgcmVtb3Zlc1xuICAgIC8vIHRoZSBvbGQgY2FsbGJhY2sgd2l0aCBlbGVtZW50Lm9mZiBhbmQgdGhlbiBjYWxsIGVsZW1lbnQub24gd2l0aCB0aGUgbmV3IG9uZS5cblxuXG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdmb2N1cycsIG9uRm9jdXMpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdlc2NhcGUnLCBvbkVzY2FwZSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2NsaWNrJywgb25DbGljayk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2xvYWRlcnJvcicsIG9uTG9hZEVycm9yKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnbG9hZGVyc3RhcnQnLCBvbkxvYWRlclN0YXJ0KTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnbmV0d29ya3NjaGFuZ2UnLCBvbk5ldHdvcmtzQ2hhbmdlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnbGluZWl0ZW1jbGljaycsIG9uTGluZUl0ZW1DbGljayk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2NvbmZpcm0nLCBvbkNvbmZpcm0pO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjYW5jZWwnLCBvbkNhbmNlbCk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3NoaXBwaW5nYWRkcmVzc2NoYW5nZScsIG9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnc2hpcHBpbmdyYXRlY2hhbmdlJywgb25TaGlwcGluZ1JhdGVDaGFuZ2UpO1xuICAgIHZhciByZWFkeUNhbGxiYWNrO1xuXG4gICAgaWYgKHR5cGUgPT09ICdjYXJ0Jykge1xuICAgICAgcmVhZHlDYWxsYmFjayA9IGZ1bmN0aW9uIHJlYWR5Q2FsbGJhY2soZXZlbnQpIHtcbiAgICAgICAgc2V0Q2FydFN0YXRlKGV2ZW50KTtcbiAgICAgICAgb25SZWFkeSAmJiBvblJlYWR5KGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvblJlYWR5KSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ3BheUJ1dHRvbicpIHtcbiAgICAgICAgLy8gUGFzc2VzIHRocm91Z2ggdGhlIGV2ZW50LCB3aGljaCBpbmNsdWRlcyB2aXNpYmxlIFBNIHR5cGVzXG4gICAgICAgIHJlYWR5Q2FsbGJhY2sgPSBvblJlYWR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG90aGVyIEVsZW1lbnRzLCBwYXNzIHRocm91Z2ggdGhlIEVsZW1lbnQgaXRzZWxmLlxuICAgICAgICByZWFkeUNhbGxiYWNrID0gZnVuY3Rpb24gcmVhZHlDYWxsYmFjaygpIHtcbiAgICAgICAgICBvblJlYWR5KGVsZW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdyZWFkeScsIHJlYWR5Q2FsbGJhY2spO1xuICAgIHZhciBjaGFuZ2VDYWxsYmFjayA9IHR5cGUgPT09ICdjYXJ0JyA/IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgc2V0Q2FydFN0YXRlKGV2ZW50KTtcbiAgICAgIG9uQ2hhbmdlICYmIG9uQ2hhbmdlKGV2ZW50KTtcbiAgICB9IDogb25DaGFuZ2U7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2NoYW5nZScsIGNoYW5nZUNhbGxiYWNrKTtcbiAgICB2YXIgY2hlY2tvdXRDYWxsYmFjayA9IHR5cGUgPT09ICdjYXJ0JyA/IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgc2V0Q2FydFN0YXRlKGV2ZW50KTtcbiAgICAgIG9uQ2hlY2tvdXQgJiYgb25DaGVja291dChldmVudCk7XG4gICAgfSA6IG9uQ2hlY2tvdXQ7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2NoZWNrb3V0JywgY2hlY2tvdXRDYWxsYmFjayk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbGVtZW50UmVmLmN1cnJlbnQgPT09IG51bGwgJiYgZWxlbWVudHMgJiYgZG9tTm9kZS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBuZXdFbGVtZW50ID0gZWxlbWVudHMuY3JlYXRlKHR5cGUsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnY2FydCcgJiYgc2V0Q2FydCkge1xuICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCBlbGVtZW50cy5jcmVhdGUgcmV0dXJuIHZhbHVlIG11c3QgYmUgb2YgdHlwZSBTdHJpcGVDYXJ0RWxlbWVudCBpZiB0eXBlIGlzICdjYXJ0JyxcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNhc3QgYmVjYXVzZSB0eXBlc2NyaXB0IGlzIG5vdCBhYmxlIHRvIGluZmVyIHdoaWNoIG92ZXJsb2FkZWQgbWV0aG9kIGlzIHVzZWQgYmFzZWQgb2ZmIHBhcmFtIHR5cGVcbiAgICAgICAgICBzZXRDYXJ0KG5ld0VsZW1lbnQpO1xuICAgICAgICB9IC8vIFN0b3JlIGVsZW1lbnQgaW4gYSByZWYgdG8gZW5zdXJlIGl0J3MgX2ltbWVkaWF0ZWx5XyBhdmFpbGFibGUgaW4gY2xlYW51cCBob29rcyBpbiBTdHJpY3RNb2RlXG5cblxuICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnQgPSBuZXdFbGVtZW50OyAvLyBTdG9yZSBlbGVtZW50IGluIHN0YXRlIHRvIGZhY2lsaXRhdGUgZXZlbnQgbGlzdGVuZXIgYXR0YWNobWVudFxuXG4gICAgICAgIHNldEVsZW1lbnQobmV3RWxlbWVudCk7XG4gICAgICAgIG5ld0VsZW1lbnQubW91bnQoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9LCBbZWxlbWVudHMsIG9wdGlvbnMsIHNldENhcnRdKTtcbiAgICB2YXIgcHJldk9wdGlvbnMgPSB1c2VQcmV2aW91cyhvcHRpb25zKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFlbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlcyA9IGV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMob3B0aW9ucywgcHJldk9wdGlvbnMsIFsncGF5bWVudFJlcXVlc3QnXSk7XG5cbiAgICAgIGlmICh1cGRhdGVzKSB7XG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudC51cGRhdGUodXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSwgW29wdGlvbnMsIHByZXZPcHRpb25zXSk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChlbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnQuZGVzdHJveSgpO1xuICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHJlZjogZG9tTm9kZVxuICAgIH0pO1xuICB9OyAvLyBPbmx5IHJlbmRlciB0aGUgRWxlbWVudCB3cmFwcGVyIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuXG5cbiAgdmFyIFNlcnZlckVsZW1lbnQgPSBmdW5jdGlvbiBTZXJ2ZXJFbGVtZW50KHByb3BzKSB7XG4gICAgLy8gVmFsaWRhdGUgdGhhdCB3ZSBhcmUgaW4gdGhlIHJpZ2h0IGNvbnRleHQgYnkgY2FsbGluZyB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZS5cbiAgICB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZShcIm1vdW50cyA8XCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIj5cIikpO1xuICAgIHVzZUNhcnRFbGVtZW50Q29udGV4dFdpdGhVc2VDYXNlKFwibW91bnRzIDxcIi5jb25jYXQoZGlzcGxheU5hbWUsIFwiPlwiKSk7XG4gICAgdmFyIGlkID0gcHJvcHMuaWQsXG4gICAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgRWxlbWVudCA9IGlzU2VydmVyID8gU2VydmVyRWxlbWVudCA6IENsaWVudEVsZW1lbnQ7XG4gIEVsZW1lbnQucHJvcFR5cGVzID0ge1xuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblJlYWR5OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkVzY2FwZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Mb2FkRXJyb3I6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTG9hZGVyU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTmV0d29ya3NDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2hlY2tvdXQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTGluZUl0ZW1DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Db25maXJtOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNhbmNlbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TaGlwcGluZ0FkZHJlc3NDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2hpcHBpbmdSYXRlQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0XG4gIH07XG4gIEVsZW1lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgRWxlbWVudC5fX2VsZW1lbnRUeXBlID0gdHlwZTtcbiAgcmV0dXJuIEVsZW1lbnQ7XG59O1xuXG52YXIgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbi8qKlxuICogUmVxdWlyZXMgYmV0YSBhY2Nlc3M6XG4gKiBDb250YWN0IFtTdHJpcGUgc3VwcG9ydF0oaHR0cHM6Ly9zdXBwb3J0LnN0cmlwZS5jb20vKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEF1QmFua0FjY291bnRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnYXVCYW5rQWNjb3VudCcsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBDYXJkRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2NhcmQnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQ2FyZE51bWJlckVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJkTnVtYmVyJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmRFeHBpcnlFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZEV4cGlyeScsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBDYXJkQ3ZjRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2NhcmRDdmMnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgRnB4QmFua0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdmcHhCYW5rJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEliYW5FbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnaWJhbicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBJZGVhbEJhbmtFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnaWRlYWxCYW5rJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIFAyNEJhbmtFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncDI0QmFuaycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBFcHNCYW5rRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2Vwc0JhbmsnLCBpc1NlcnZlcik7XG52YXIgUGF5bWVudEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdwYXltZW50JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBSZXF1aXJlcyBiZXRhIGFjY2VzczpcbiAqIENvbnRhY3QgW1N0cmlwZSBzdXBwb3J0XShodHRwczovL3N1cHBvcnQuc3RyaXBlLmNvbS8pIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgUGF5QnV0dG9uRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3BheUJ1dHRvbicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBQYXltZW50UmVxdWVzdEJ1dHRvbkVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdwYXltZW50UmVxdWVzdEJ1dHRvbicsIGlzU2VydmVyKTtcbi8qKlxuICogUmVxdWlyZXMgYmV0YSBhY2Nlc3M6XG4gKiBDb250YWN0IFtTdHJpcGUgc3VwcG9ydF0oaHR0cHM6Ly9zdXBwb3J0LnN0cmlwZS5jb20vKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIExpbmtBdXRoZW50aWNhdGlvbkVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdsaW5rQXV0aGVudGljYXRpb24nLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQWRkcmVzc0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdhZGRyZXNzJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVXNlIGBBZGRyZXNzRWxlbWVudGAgaW5zdGVhZC5cbiAqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIFNoaXBwaW5nQWRkcmVzc0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdzaGlwcGluZ0FkZHJlc3MnLCBpc1NlcnZlcik7XG4vKipcbiAqIFJlcXVpcmVzIGJldGEgYWNjZXNzOlxuICogQ29udGFjdCBbU3RyaXBlIHN1cHBvcnRdKGh0dHBzOi8vc3VwcG9ydC5zdHJpcGUuY29tLykgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3MvZWxlbWVudHMvY2FydC1lbGVtZW50XG4gKi9cblxudmFyIENhcnRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FydCcsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBQYXltZW50TWV0aG9kTWVzc2FnaW5nRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3BheW1lbnRNZXRob2RNZXNzYWdpbmcnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQWZmaXJtTWVzc2FnZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdhZmZpcm1NZXNzYWdlJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEFmdGVycGF5Q2xlYXJwYXlNZXNzYWdlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2FmdGVycGF5Q2xlYXJwYXlNZXNzYWdlJywgaXNTZXJ2ZXIpO1xuXG5leHBvcnQgeyBBZGRyZXNzRWxlbWVudCwgQWZmaXJtTWVzc2FnZUVsZW1lbnQsIEFmdGVycGF5Q2xlYXJwYXlNZXNzYWdlRWxlbWVudCwgQXVCYW5rQWNjb3VudEVsZW1lbnQsIENhcmRDdmNFbGVtZW50LCBDYXJkRWxlbWVudCwgQ2FyZEV4cGlyeUVsZW1lbnQsIENhcmROdW1iZXJFbGVtZW50LCBDYXJ0RWxlbWVudCwgRWxlbWVudHMsIEVsZW1lbnRzQ29uc3VtZXIsIEVwc0JhbmtFbGVtZW50LCBGcHhCYW5rRWxlbWVudCwgSWJhbkVsZW1lbnQsIElkZWFsQmFua0VsZW1lbnQsIExpbmtBdXRoZW50aWNhdGlvbkVsZW1lbnQsIFAyNEJhbmtFbGVtZW50LCBQYXlCdXR0b25FbGVtZW50LCBQYXltZW50RWxlbWVudCwgUGF5bWVudE1ldGhvZE1lc3NhZ2luZ0VsZW1lbnQsIFBheW1lbnRSZXF1ZXN0QnV0dG9uRWxlbWVudCwgU2hpcHBpbmdBZGRyZXNzRWxlbWVudCwgdXNlQ2FydEVsZW1lbnQsIHVzZUNhcnRFbGVtZW50U3RhdGUsIHVzZUVsZW1lbnRzLCB1c2VTdHJpcGUgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlByb3BUeXBlcyIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQyIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImZvckVhY2giLCJrZXkiLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiQXJyYXkiLCJpc0FycmF5IiwiX2kiLCJfYXJyIiwiX24iLCJfZCIsIl9zIiwiX2UiLCJjYWxsIiwibmV4dCIsImRvbmUiLCJlcnIiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJmcm9tIiwidGVzdCIsImxlbiIsImFycjIiLCJUeXBlRXJyb3IiLCJ1c2VQcmV2aW91cyIsInJlZiIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJpc1Vua25vd25PYmplY3QiLCJyYXciLCJpc1Byb21pc2UiLCJ0aGVuIiwiaXNTdHJpcGUiLCJlbGVtZW50cyIsImNyZWF0ZVRva2VuIiwiY3JlYXRlUGF5bWVudE1ldGhvZCIsImNvbmZpcm1DYXJkUGF5bWVudCIsIlBMQUlOX09CSkVDVF9TVFIiLCJpc0VxdWFsIiwibGVmdCIsInJpZ2h0IiwibGVmdEFycmF5IiwicmlnaHRBcnJheSIsImxlZnRQbGFpbk9iamVjdCIsInJpZ2h0UGxhaW5PYmplY3QiLCJsZWZ0S2V5cyIsInJpZ2h0S2V5cyIsImtleVNldCIsImFsbEtleXMiLCJsIiwiciIsInByZWQiLCJldmVyeSIsImV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMiLCJvcHRpb25zIiwicHJldk9wdGlvbnMiLCJpbW11dGFibGVLZXlzIiwicmVkdWNlIiwibmV3T3B0aW9ucyIsImlzVXBkYXRlZCIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iLCJjb25jYXQiLCJJTlZBTElEX1NUUklQRV9FUlJPUiIsInZhbGlkYXRlU3RyaXBlIiwibWF5YmVTdHJpcGUiLCJFcnJvciIsInBhcnNlU3RyaXBlUHJvcCIsInRhZyIsInN0cmlwZVByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInN0cmlwZSIsIkVsZW1lbnRzQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsInBhcnNlRWxlbWVudHNDb250ZXh0IiwiY3R4IiwidXNlQ2FzZSIsIkNhcnRFbGVtZW50Q29udGV4dCIsInBhcnNlQ2FydEVsZW1lbnRDb250ZXh0IiwiRWxlbWVudHMiLCJfcmVmIiwicmF3U3RyaXBlUHJvcCIsImNoaWxkcmVuIiwicGFyc2VkIiwidXNlTWVtbyIsIl9SZWFjdCR1c2VTdGF0ZSIsInVzZVN0YXRlIiwiX1JlYWN0JHVzZVN0YXRlMiIsImNhcnQiLCJzZXRDYXJ0IiwiX1JlYWN0JHVzZVN0YXRlMyIsIl9SZWFjdCR1c2VTdGF0ZTQiLCJjYXJ0U3RhdGUiLCJzZXRDYXJ0U3RhdGUiLCJfUmVhY3QkdXNlU3RhdGU1IiwiX1JlYWN0JHVzZVN0YXRlNiIsInNldENvbnRleHQiLCJpc01vdW50ZWQiLCJzYWZlU2V0Q29udGV4dCIsInByZXZTdHJpcGUiLCJ1cGRhdGVzIiwidXBkYXRlIiwiYW55U3RyaXBlIiwiX3JlZ2lzdGVyV3JhcHBlciIsInJlZ2lzdGVyQXBwSW5mbyIsInZlcnNpb24iLCJ1cmwiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJwcm9wVHlwZXMiLCJhbnkiLCJ1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZSIsInVzZUNhc2VNZXNzYWdlIiwidXNlQ29udGV4dCIsInVzZUNhcnRFbGVtZW50Q29udGV4dFdpdGhVc2VDYXNlIiwidXNlRWxlbWVudHMiLCJfdXNlRWxlbWVudHNDb250ZXh0V2kiLCJ1c2VTdHJpcGUiLCJfdXNlRWxlbWVudHNDb250ZXh0V2kyIiwidXNlQ2FydEVsZW1lbnQiLCJfdXNlQ2FydEVsZW1lbnRDb250ZXgiLCJ1c2VDYXJ0RWxlbWVudFN0YXRlIiwiX3VzZUNhcnRFbGVtZW50Q29udGV4MiIsIkVsZW1lbnRzQ29uc3VtZXIiLCJfcmVmMiIsImZ1bmMiLCJpc1JlcXVpcmVkIiwidXNlQXR0YWNoRXZlbnQiLCJlbGVtZW50IiwiZXZlbnQiLCJjYiIsImNiRGVmaW5lZCIsImNiUmVmIiwiZGVjb3JhdGVkQ2IiLCJvbiIsIm9mZiIsImNhcGl0YWxpemVkIiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJjcmVhdGVFbGVtZW50Q29tcG9uZW50IiwidHlwZSIsImlzU2VydmVyIiwiQ2xpZW50RWxlbWVudCIsImlkIiwiY2xhc3NOYW1lIiwiX3JlZiRvcHRpb25zIiwib25CbHVyIiwib25Gb2N1cyIsIm9uUmVhZHkiLCJvbkNoYW5nZSIsIm9uRXNjYXBlIiwib25DbGljayIsIm9uTG9hZEVycm9yIiwib25Mb2FkZXJTdGFydCIsIm9uTmV0d29ya3NDaGFuZ2UiLCJvbkNoZWNrb3V0Iiwib25MaW5lSXRlbUNsaWNrIiwib25Db25maXJtIiwib25DYW5jZWwiLCJvblNoaXBwaW5nQWRkcmVzc0NoYW5nZSIsIm9uU2hpcHBpbmdSYXRlQ2hhbmdlIiwic2V0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJkb21Ob2RlIiwicmVhZHlDYWxsYmFjayIsImNoYW5nZUNhbGxiYWNrIiwiY2hlY2tvdXRDYWxsYmFjayIsInVzZUxheW91dEVmZmVjdCIsIm5ld0VsZW1lbnQiLCJjcmVhdGUiLCJtb3VudCIsImRlc3Ryb3kiLCJTZXJ2ZXJFbGVtZW50IiwicHJvcHMiLCJFbGVtZW50Iiwic3RyaW5nIiwiX19lbGVtZW50VHlwZSIsIkF1QmFua0FjY291bnRFbGVtZW50IiwiQ2FyZEVsZW1lbnQiLCJDYXJkTnVtYmVyRWxlbWVudCIsIkNhcmRFeHBpcnlFbGVtZW50IiwiQ2FyZEN2Y0VsZW1lbnQiLCJGcHhCYW5rRWxlbWVudCIsIkliYW5FbGVtZW50IiwiSWRlYWxCYW5rRWxlbWVudCIsIlAyNEJhbmtFbGVtZW50IiwiRXBzQmFua0VsZW1lbnQiLCJQYXltZW50RWxlbWVudCIsIlBheUJ1dHRvbkVsZW1lbnQiLCJQYXltZW50UmVxdWVzdEJ1dHRvbkVsZW1lbnQiLCJMaW5rQXV0aGVudGljYXRpb25FbGVtZW50IiwiQWRkcmVzc0VsZW1lbnQiLCJTaGlwcGluZ0FkZHJlc3NFbGVtZW50IiwiQ2FydEVsZW1lbnQiLCJQYXltZW50TWV0aG9kTWVzc2FnaW5nRWxlbWVudCIsIkFmZmlybU1lc3NhZ2VFbGVtZW50IiwiQWZ0ZXJwYXlDbGVhcnBheU1lc3NhZ2VFbGVtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/checkPropTypes.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/node_modules/prop-types/checkPropTypes.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nvar printWarning = function() {};\nif (true) {\n    var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n    var loggedTypeFailures = {};\n    var has = __webpack_require__(/*! ./lib/has */ \"(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/lib/has.js\");\n    printWarning = function(text) {\n        var message = \"Warning: \" + text;\n        if (typeof console !== \"undefined\") {\n            console.error(message);\n        }\n        try {\n            // --- Welcome to debugging React ---\n            // This error was thrown as a convenience so that you can use this stack\n            // to find the callsite that caused this warning to fire.\n            throw new Error(message);\n        } catch (x) {}\n    };\n}\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n    if (true) {\n        for(var typeSpecName in typeSpecs){\n            if (has(typeSpecs, typeSpecName)) {\n                var error;\n                // Prop type validation may throw. In case they do, we don't want to\n                // fail the render phase where it didn't fail before. So we log it.\n                // After these have been cleaned up, we'll let them throw.\n                try {\n                    // This is intentionally an invariant that gets caught. It's the same\n                    // behavior as without this statement except with a better message.\n                    if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                        var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                        err.name = \"Invariant Violation\";\n                        throw err;\n                    }\n                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n                } catch (ex) {\n                    error = ex;\n                }\n                if (error && !(error instanceof Error)) {\n                    printWarning((componentName || \"React class\") + \": type specification of \" + location + \" `\" + typeSpecName + \"` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a \" + typeof error + \". \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\");\n                }\n                if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                    // Only monitor this failure once because there tends to be a lot of the\n                    // same error.\n                    loggedTypeFailures[error.message] = true;\n                    var stack = getStack ? getStack() : \"\";\n                    printWarning(\"Failed \" + location + \" type: \" + error.message + (stack != null ? stack : \"\"));\n                }\n            }\n        }\n    }\n}\n/**\n * Resets warning cache when testing.\n *\n * @private\n */ checkPropTypes.resetWarningCache = function() {\n    if (true) {\n        loggedTypeFailures = {};\n    }\n};\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0MsR0FFRDtBQUVBLElBQUlBLGVBQWUsWUFBWTtBQUUvQixJQUFJQyxJQUF5QixFQUFjO0lBQ3pDLElBQUlDLHVCQUF1QkMsbUJBQU9BLENBQUM7SUFDbkMsSUFBSUMscUJBQXFCLENBQUM7SUFDMUIsSUFBSUMsTUFBTUYsbUJBQU9BLENBQUM7SUFFbEJILGVBQWUsU0FBU00sSUFBSTtRQUMxQixJQUFJQyxVQUFVLGNBQWNEO1FBQzVCLElBQUksT0FBT0UsWUFBWSxhQUFhO1lBQ2xDQSxRQUFRQyxLQUFLLENBQUNGO1FBQ2hCO1FBQ0EsSUFBSTtZQUNGLHFDQUFxQztZQUNyQyx3RUFBd0U7WUFDeEUseURBQXlEO1lBQ3pELE1BQU0sSUFBSUcsTUFBTUg7UUFDbEIsRUFBRSxPQUFPSSxHQUFHLENBQU87SUFDckI7QUFDRjtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTQyxlQUFlQyxTQUFTLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUVDLFFBQVE7SUFDMUUsSUFBSWhCLElBQXlCLEVBQWM7UUFDekMsSUFBSyxJQUFJaUIsZ0JBQWdCTCxVQUFXO1lBQ2xDLElBQUlSLElBQUlRLFdBQVdLLGVBQWU7Z0JBQ2hDLElBQUlUO2dCQUNKLG9FQUFvRTtnQkFDcEUsbUVBQW1FO2dCQUNuRSwwREFBMEQ7Z0JBQzFELElBQUk7b0JBQ0YscUVBQXFFO29CQUNyRSxtRUFBbUU7b0JBQ25FLElBQUksT0FBT0ksU0FBUyxDQUFDSyxhQUFhLEtBQUssWUFBWTt3QkFDakQsSUFBSUMsTUFBTVQsTUFDUixDQUFDTSxpQkFBaUIsYUFBWSxJQUFLLE9BQU9ELFdBQVcsWUFBWUcsZUFBZSxtQkFDaEYsaUZBQWlGLE9BQU9MLFNBQVMsQ0FBQ0ssYUFBYSxHQUFHLE9BQ2xIO3dCQUVGQyxJQUFJQyxJQUFJLEdBQUc7d0JBQ1gsTUFBTUQ7b0JBQ1I7b0JBQ0FWLFFBQVFJLFNBQVMsQ0FBQ0ssYUFBYSxDQUFDSixRQUFRSSxjQUFjRixlQUFlRCxVQUFVLE1BQU1iO2dCQUN2RixFQUFFLE9BQU9tQixJQUFJO29CQUNYWixRQUFRWTtnQkFDVjtnQkFDQSxJQUFJWixTQUFTLENBQUVBLENBQUFBLGlCQUFpQkMsS0FBSSxHQUFJO29CQUN0Q1YsYUFDRSxDQUFDZ0IsaUJBQWlCLGFBQVksSUFBSyw2QkFDbkNELFdBQVcsT0FBT0csZUFBZSxvQ0FDakMsOERBQThELE9BQU9ULFFBQVEsT0FDN0Usb0VBQ0EsbUVBQ0E7Z0JBRUo7Z0JBQ0EsSUFBSUEsaUJBQWlCQyxTQUFTLENBQUVELENBQUFBLE1BQU1GLE9BQU8sSUFBSUgsa0JBQWlCLEdBQUk7b0JBQ3BFLHdFQUF3RTtvQkFDeEUsY0FBYztvQkFDZEEsa0JBQWtCLENBQUNLLE1BQU1GLE9BQU8sQ0FBQyxHQUFHO29CQUVwQyxJQUFJZSxRQUFRTCxXQUFXQSxhQUFhO29CQUVwQ2pCLGFBQ0UsWUFBWWUsV0FBVyxZQUFZTixNQUFNRixPQUFPLEdBQUllLENBQUFBLFNBQVMsT0FBT0EsUUFBUSxFQUFDO2dCQUVqRjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNEVixlQUFlVyxpQkFBaUIsR0FBRztJQUNqQyxJQUFJdEIsSUFBeUIsRUFBYztRQUN6Q0cscUJBQXFCLENBQUM7SUFDeEI7QUFDRjtBQUVBb0IsT0FBT0MsT0FBTyxHQUFHYiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3RyaXBlL3JlYWN0LXN0cmlwZS1qcy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcz9mMDc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHsgLyoqLyB9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICtcbiAgICAgICAgICAgICAgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIl0sIm5hbWVzIjpbInByaW50V2FybmluZyIsInByb2Nlc3MiLCJSZWFjdFByb3BUeXBlc1NlY3JldCIsInJlcXVpcmUiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJoYXMiLCJ0ZXh0IiwibWVzc2FnZSIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwieCIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJlcnIiLCJuYW1lIiwiZXgiLCJzdGFjayIsInJlc2V0V2FybmluZ0NhY2hlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/checkPropTypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/factoryWithTypeCheckers.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nvar ReactIs = __webpack_require__(/*! react-is */ \"(ssr)/./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"(ssr)/./node_modules/object-assign/index.js\");\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar has = __webpack_require__(/*! ./lib/has */ \"(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/lib/has.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/checkPropTypes.js\");\nvar printWarning = function() {};\nif (true) {\n    printWarning = function(text) {\n        var message = \"Warning: \" + text;\n        if (typeof console !== \"undefined\") {\n            console.error(message);\n        }\n        try {\n            // --- Welcome to debugging React ---\n            // This error was thrown as a convenience so that you can use this stack\n            // to find the callsite that caused this warning to fire.\n            throw new Error(message);\n        } catch (x) {}\n    };\n}\nfunction emptyFunctionThatReturnsNull() {\n    return null;\n}\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = \"@@iterator\"; // Before Symbol spec.\n    /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */ function getIteratorFn(maybeIterable) {\n        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n        if (typeof iteratorFn === \"function\") {\n            return iteratorFn;\n        }\n    }\n    /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */ var ANONYMOUS = \"<<anonymous>>\";\n    // Important!\n    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n    var ReactPropTypes = {\n        array: createPrimitiveTypeChecker(\"array\"),\n        bigint: createPrimitiveTypeChecker(\"bigint\"),\n        bool: createPrimitiveTypeChecker(\"boolean\"),\n        func: createPrimitiveTypeChecker(\"function\"),\n        number: createPrimitiveTypeChecker(\"number\"),\n        object: createPrimitiveTypeChecker(\"object\"),\n        string: createPrimitiveTypeChecker(\"string\"),\n        symbol: createPrimitiveTypeChecker(\"symbol\"),\n        any: createAnyTypeChecker(),\n        arrayOf: createArrayOfTypeChecker,\n        element: createElementTypeChecker(),\n        elementType: createElementTypeTypeChecker(),\n        instanceOf: createInstanceTypeChecker,\n        node: createNodeChecker(),\n        objectOf: createObjectOfTypeChecker,\n        oneOf: createEnumTypeChecker,\n        oneOfType: createUnionTypeChecker,\n        shape: createShapeTypeChecker,\n        exact: createStrictShapeTypeChecker\n    };\n    /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */ /*eslint-disable no-self-compare*/ function is(x, y) {\n        // SameValue algorithm\n        if (x === y) {\n            // Steps 1-5, 7-10\n            // Steps 6.b-6.e: +0 != -0\n            return x !== 0 || 1 / x === 1 / y;\n        } else {\n            // Step 6.a: NaN == NaN\n            return x !== x && y !== y;\n        }\n    }\n    /*eslint-enable no-self-compare*/ /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */ function PropTypeError(message, data) {\n        this.message = message;\n        this.data = data && typeof data === \"object\" ? data : {};\n        this.stack = \"\";\n    }\n    // Make `instanceof Error` still work for returned errors.\n    PropTypeError.prototype = Error.prototype;\n    function createChainableTypeChecker(validate) {\n        if (true) {\n            var manualPropTypeCallCache = {};\n            var manualPropTypeWarningCount = 0;\n        }\n        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n            componentName = componentName || ANONYMOUS;\n            propFullName = propFullName || propName;\n            if (secret !== ReactPropTypesSecret) {\n                if (throwOnDirectAccess) {\n                    // New behavior only for users of `prop-types` package\n                    var err = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use `PropTypes.checkPropTypes()` to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                    err.name = \"Invariant Violation\";\n                    throw err;\n                } else if ( true && typeof console !== \"undefined\") {\n                    // Old behavior for people using React.PropTypes\n                    var cacheKey = componentName + \":\" + propName;\n                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n                    manualPropTypeWarningCount < 3) {\n                        printWarning(\"You are manually calling a React.PropTypes validation \" + \"function for the `\" + propFullName + \"` prop on `\" + componentName + \"`. This is deprecated \" + \"and will throw in the standalone `prop-types` package. \" + \"You may be seeing this warning due to a third-party PropTypes \" + \"library. See https://fb.me/react-warning-dont-call-proptypes \" + \"for details.\");\n                        manualPropTypeCallCache[cacheKey] = true;\n                        manualPropTypeWarningCount++;\n                    }\n                }\n            }\n            if (props[propName] == null) {\n                if (isRequired) {\n                    if (props[propName] === null) {\n                        return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n                    }\n                    return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n                }\n                return null;\n            } else {\n                return validate(props, propName, componentName, location, propFullName);\n            }\n        }\n        var chainedCheckType = checkType.bind(null, false);\n        chainedCheckType.isRequired = checkType.bind(null, true);\n        return chainedCheckType;\n    }\n    function createPrimitiveTypeChecker(expectedType) {\n        function validate(props, propName, componentName, location, propFullName, secret) {\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n            if (propType !== expectedType) {\n                // `propValue` being instance of, say, date/regexp, pass the 'object'\n                // check, but we can offer a more precise error message here rather than\n                // 'of type `object`'.\n                var preciseType = getPreciseType(propValue);\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"), {\n                    expectedType: expectedType\n                });\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createAnyTypeChecker() {\n        return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n    }\n    function createArrayOfTypeChecker(typeChecker) {\n        function validate(props, propName, componentName, location, propFullName) {\n            if (typeof typeChecker !== \"function\") {\n                return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n            }\n            var propValue = props[propName];\n            if (!Array.isArray(propValue)) {\n                var propType = getPropType(propValue);\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n            }\n            for(var i = 0; i < propValue.length; i++){\n                var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret);\n                if (error instanceof Error) {\n                    return error;\n                }\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createElementTypeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            if (!isValidElement(propValue)) {\n                var propType = getPropType(propValue);\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createElementTypeTypeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            if (!ReactIs.isValidElementType(propValue)) {\n                var propType = getPropType(propValue);\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement type.\"));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createInstanceTypeChecker(expectedClass) {\n        function validate(props, propName, componentName, location, propFullName) {\n            if (!(props[propName] instanceof expectedClass)) {\n                var expectedClassName = expectedClass.name || ANONYMOUS;\n                var actualClassName = getClassName(props[propName]);\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createEnumTypeChecker(expectedValues) {\n        if (!Array.isArray(expectedValues)) {\n            if (true) {\n                if (arguments.length > 1) {\n                    printWarning(\"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. \" + \"A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\");\n                } else {\n                    printWarning(\"Invalid argument supplied to oneOf, expected an array.\");\n                }\n            }\n            return emptyFunctionThatReturnsNull;\n        }\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            for(var i = 0; i < expectedValues.length; i++){\n                if (is(propValue, expectedValues[i])) {\n                    return null;\n                }\n            }\n            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n                var type = getPreciseType(value);\n                if (type === \"symbol\") {\n                    return String(value);\n                }\n                return value;\n            });\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + String(propValue) + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createObjectOfTypeChecker(typeChecker) {\n        function validate(props, propName, componentName, location, propFullName) {\n            if (typeof typeChecker !== \"function\") {\n                return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n            }\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n            if (propType !== \"object\") {\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n            }\n            for(var key in propValue){\n                if (has(propValue, key)) {\n                    var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                    if (error instanceof Error) {\n                        return error;\n                    }\n                }\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createUnionTypeChecker(arrayOfTypeCheckers) {\n        if (!Array.isArray(arrayOfTypeCheckers)) {\n             true ? printWarning(\"Invalid argument supplied to oneOfType, expected an instance of array.\") : 0;\n            return emptyFunctionThatReturnsNull;\n        }\n        for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n            var checker = arrayOfTypeCheckers[i];\n            if (typeof checker !== \"function\") {\n                printWarning(\"Invalid argument supplied to oneOfType. Expected an array of check functions, but \" + \"received \" + getPostfixForTypeWarning(checker) + \" at index \" + i + \".\");\n                return emptyFunctionThatReturnsNull;\n            }\n        }\n        function validate(props, propName, componentName, location, propFullName) {\n            var expectedTypes = [];\n            for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                var checker = arrayOfTypeCheckers[i];\n                var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n                if (checkerResult == null) {\n                    return null;\n                }\n                if (checkerResult.data && has(checkerResult.data, \"expectedType\")) {\n                    expectedTypes.push(checkerResult.data.expectedType);\n                }\n            }\n            var expectedTypesMessage = expectedTypes.length > 0 ? \", expected one of type [\" + expectedTypes.join(\", \") + \"]\" : \"\";\n            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`\" + expectedTypesMessage + \".\"));\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createNodeChecker() {\n        function validate(props, propName, componentName, location, propFullName) {\n            if (!isNode(props[propName])) {\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function invalidValidatorError(componentName, location, propFullName, key, type) {\n        return new PropTypeError((componentName || \"React class\") + \": \" + location + \" type `\" + propFullName + \".\" + key + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + type + \"`.\");\n    }\n    function createShapeTypeChecker(shapeTypes) {\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n            if (propType !== \"object\") {\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n            }\n            for(var key in shapeTypes){\n                var checker = shapeTypes[key];\n                if (typeof checker !== \"function\") {\n                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n                }\n                var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                if (error) {\n                    return error;\n                }\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function createStrictShapeTypeChecker(shapeTypes) {\n        function validate(props, propName, componentName, location, propFullName) {\n            var propValue = props[propName];\n            var propType = getPropType(propValue);\n            if (propType !== \"object\") {\n                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n            }\n            // We need to check all keys in case some are required but missing from props.\n            var allKeys = assign({}, props[propName], shapeTypes);\n            for(var key in allKeys){\n                var checker = shapeTypes[key];\n                if (has(shapeTypes, key) && typeof checker !== \"function\") {\n                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n                }\n                if (!checker) {\n                    return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\" + \"\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \"));\n                }\n                var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                if (error) {\n                    return error;\n                }\n            }\n            return null;\n        }\n        return createChainableTypeChecker(validate);\n    }\n    function isNode(propValue) {\n        switch(typeof propValue){\n            case \"number\":\n            case \"string\":\n            case \"undefined\":\n                return true;\n            case \"boolean\":\n                return !propValue;\n            case \"object\":\n                if (Array.isArray(propValue)) {\n                    return propValue.every(isNode);\n                }\n                if (propValue === null || isValidElement(propValue)) {\n                    return true;\n                }\n                var iteratorFn = getIteratorFn(propValue);\n                if (iteratorFn) {\n                    var iterator = iteratorFn.call(propValue);\n                    var step;\n                    if (iteratorFn !== propValue.entries) {\n                        while(!(step = iterator.next()).done){\n                            if (!isNode(step.value)) {\n                                return false;\n                            }\n                        }\n                    } else {\n                        // Iterator will provide entry [k,v] tuples rather than values.\n                        while(!(step = iterator.next()).done){\n                            var entry = step.value;\n                            if (entry) {\n                                if (!isNode(entry[1])) {\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    return false;\n                }\n                return true;\n            default:\n                return false;\n        }\n    }\n    function isSymbol(propType, propValue) {\n        // Native Symbol.\n        if (propType === \"symbol\") {\n            return true;\n        }\n        // falsy value can't be a Symbol\n        if (!propValue) {\n            return false;\n        }\n        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n        if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n            return true;\n        }\n        // Fallback for non-spec compliant Symbols which are polyfilled.\n        if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n            return true;\n        }\n        return false;\n    }\n    // Equivalent of `typeof` but with special handling for array and regexp.\n    function getPropType(propValue) {\n        var propType = typeof propValue;\n        if (Array.isArray(propValue)) {\n            return \"array\";\n        }\n        if (propValue instanceof RegExp) {\n            // Old webkits (at least until Android 4.0) return 'function' rather than\n            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n            // passes PropTypes.object.\n            return \"object\";\n        }\n        if (isSymbol(propType, propValue)) {\n            return \"symbol\";\n        }\n        return propType;\n    }\n    // This handles more types than `getPropType`. Only used for error messages.\n    // See `createPrimitiveTypeChecker`.\n    function getPreciseType(propValue) {\n        if (typeof propValue === \"undefined\" || propValue === null) {\n            return \"\" + propValue;\n        }\n        var propType = getPropType(propValue);\n        if (propType === \"object\") {\n            if (propValue instanceof Date) {\n                return \"date\";\n            } else if (propValue instanceof RegExp) {\n                return \"regexp\";\n            }\n        }\n        return propType;\n    }\n    // Returns a string that is postfixed to a warning about an invalid type.\n    // For example, \"undefined\" or \"of type array\"\n    function getPostfixForTypeWarning(value) {\n        var type = getPreciseType(value);\n        switch(type){\n            case \"array\":\n            case \"object\":\n                return \"an \" + type;\n            case \"boolean\":\n            case \"date\":\n            case \"regexp\":\n                return \"a \" + type;\n            default:\n                return type;\n        }\n    }\n    // Returns class name of the object, if any.\n    function getClassName(propValue) {\n        if (!propValue.constructor || !propValue.constructor.name) {\n            return ANONYMOUS;\n        }\n        return propValue.constructor.name;\n    }\n    ReactPropTypes.checkPropTypes = checkPropTypes;\n    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n    ReactPropTypes.PropTypes = ReactPropTypes;\n    return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0MsR0FFRDtBQUVBLElBQUlBLFVBQVVDLG1CQUFPQSxDQUFDO0FBQ3RCLElBQUlDLFNBQVNELG1CQUFPQSxDQUFDO0FBRXJCLElBQUlFLHVCQUF1QkYsbUJBQU9BLENBQUM7QUFDbkMsSUFBSUcsTUFBTUgsbUJBQU9BLENBQUM7QUFDbEIsSUFBSUksaUJBQWlCSixtQkFBT0EsQ0FBQztBQUU3QixJQUFJSyxlQUFlLFlBQVk7QUFFL0IsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0QsZUFBZSxTQUFTRSxJQUFJO1FBQzFCLElBQUlDLFVBQVUsY0FBY0Q7UUFDNUIsSUFBSSxPQUFPRSxZQUFZLGFBQWE7WUFDbENBLFFBQVFDLEtBQUssQ0FBQ0Y7UUFDaEI7UUFDQSxJQUFJO1lBQ0YscUNBQXFDO1lBQ3JDLHdFQUF3RTtZQUN4RSx5REFBeUQ7WUFDekQsTUFBTSxJQUFJRyxNQUFNSDtRQUNsQixFQUFFLE9BQU9JLEdBQUcsQ0FBQztJQUNmO0FBQ0Y7QUFFQSxTQUFTQztJQUNQLE9BQU87QUFDVDtBQUVBQyxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsY0FBYyxFQUFFQyxtQkFBbUI7SUFDM0QsaUJBQWlCLEdBQ2pCLElBQUlDLGtCQUFrQixPQUFPQyxXQUFXLGNBQWNBLE9BQU9DLFFBQVE7SUFDckUsSUFBSUMsdUJBQXVCLGNBQWMsc0JBQXNCO0lBRS9EOzs7Ozs7Ozs7Ozs7O0dBYUMsR0FDRCxTQUFTQyxjQUFjQyxhQUFhO1FBQ2xDLElBQUlDLGFBQWFELGlCQUFrQkwsQ0FBQUEsbUJBQW1CSyxhQUFhLENBQUNMLGdCQUFnQixJQUFJSyxhQUFhLENBQUNGLHFCQUFxQjtRQUMzSCxJQUFJLE9BQU9HLGVBQWUsWUFBWTtZQUNwQyxPQUFPQTtRQUNUO0lBQ0Y7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkNDLEdBRUQsSUFBSUMsWUFBWTtJQUVoQixhQUFhO0lBQ2IscUZBQXFGO0lBQ3JGLElBQUlDLGlCQUFpQjtRQUNuQkMsT0FBT0MsMkJBQTJCO1FBQ2xDQyxRQUFRRCwyQkFBMkI7UUFDbkNFLE1BQU1GLDJCQUEyQjtRQUNqQ0csTUFBTUgsMkJBQTJCO1FBQ2pDSSxRQUFRSiwyQkFBMkI7UUFDbkNLLFFBQVFMLDJCQUEyQjtRQUNuQ00sUUFBUU4sMkJBQTJCO1FBQ25DTyxRQUFRUCwyQkFBMkI7UUFFbkNRLEtBQUtDO1FBQ0xDLFNBQVNDO1FBQ1RDLFNBQVNDO1FBQ1RDLGFBQWFDO1FBQ2JDLFlBQVlDO1FBQ1pDLE1BQU1DO1FBQ05DLFVBQVVDO1FBQ1ZDLE9BQU9DO1FBQ1BDLFdBQVdDO1FBQ1hDLE9BQU9DO1FBQ1BDLE9BQU9DO0lBQ1Q7SUFFQTs7O0dBR0MsR0FDRCxnQ0FBZ0MsR0FDaEMsU0FBU0MsR0FBRzlDLENBQUMsRUFBRStDLENBQUM7UUFDZCxzQkFBc0I7UUFDdEIsSUFBSS9DLE1BQU0rQyxHQUFHO1lBQ1gsa0JBQWtCO1lBQ2xCLDBCQUEwQjtZQUMxQixPQUFPL0MsTUFBTSxLQUFLLElBQUlBLE1BQU0sSUFBSStDO1FBQ2xDLE9BQU87WUFDTCx1QkFBdUI7WUFDdkIsT0FBTy9DLE1BQU1BLEtBQUsrQyxNQUFNQTtRQUMxQjtJQUNGO0lBQ0EsK0JBQStCLEdBRS9COzs7Ozs7R0FNQyxHQUNELFNBQVNDLGNBQWNwRCxPQUFPLEVBQUVxRCxJQUFJO1FBQ2xDLElBQUksQ0FBQ3JELE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNxRCxJQUFJLEdBQUdBLFFBQVEsT0FBT0EsU0FBUyxXQUFXQSxPQUFNLENBQUM7UUFDdEQsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDZjtJQUNBLDBEQUEwRDtJQUMxREYsY0FBY0csU0FBUyxHQUFHcEQsTUFBTW9ELFNBQVM7SUFFekMsU0FBU0MsMkJBQTJCQyxRQUFRO1FBQzFDLElBQUkzRCxJQUF5QixFQUFjO1lBQ3pDLElBQUk0RCwwQkFBMEIsQ0FBQztZQUMvQixJQUFJQyw2QkFBNkI7UUFDbkM7UUFDQSxTQUFTQyxVQUFVQyxVQUFVLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUVDLFFBQVEsRUFBRUMsWUFBWSxFQUFFQyxNQUFNO1lBQzNGSCxnQkFBZ0JBLGlCQUFpQi9DO1lBQ2pDaUQsZUFBZUEsZ0JBQWdCSDtZQUUvQixJQUFJSSxXQUFXekUsc0JBQXNCO2dCQUNuQyxJQUFJZSxxQkFBcUI7b0JBQ3ZCLHNEQUFzRDtvQkFDdEQsSUFBSTJELE1BQU0sSUFBSWpFLE1BQ1oseUZBQ0Esb0RBQ0E7b0JBRUZpRSxJQUFJQyxJQUFJLEdBQUc7b0JBQ1gsTUFBTUQ7Z0JBQ1IsT0FBTyxJQUFJdEUsS0FBeUIsSUFBZ0IsT0FBT0csWUFBWSxhQUFhO29CQUNsRixnREFBZ0Q7b0JBQ2hELElBQUlxRSxXQUFXTixnQkFBZ0IsTUFBTUQ7b0JBQ3JDLElBQ0UsQ0FBQ0wsdUJBQXVCLENBQUNZLFNBQVMsSUFDbEMsMEZBQTBGO29CQUMxRlgsNkJBQTZCLEdBQzdCO3dCQUNBOUQsYUFDRSwyREFDQSx1QkFBdUJxRSxlQUFlLGdCQUFnQkYsZ0JBQWdCLDJCQUN0RSw0REFDQSxtRUFDQSxrRUFBa0U7d0JBRXBFTix1QkFBdUIsQ0FBQ1ksU0FBUyxHQUFHO3dCQUNwQ1g7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBLElBQUlHLEtBQUssQ0FBQ0MsU0FBUyxJQUFJLE1BQU07Z0JBQzNCLElBQUlGLFlBQVk7b0JBQ2QsSUFBSUMsS0FBSyxDQUFDQyxTQUFTLEtBQUssTUFBTTt3QkFDNUIsT0FBTyxJQUFJWCxjQUFjLFNBQVNhLFdBQVcsT0FBT0MsZUFBZSw2QkFBOEIsVUFBU0YsZ0JBQWdCLDZCQUE0QjtvQkFDeEo7b0JBQ0EsT0FBTyxJQUFJWixjQUFjLFNBQVNhLFdBQVcsT0FBT0MsZUFBZSxnQ0FBaUMsT0FBTUYsZ0JBQWdCLGtDQUFpQztnQkFDN0o7Z0JBQ0EsT0FBTztZQUNULE9BQU87Z0JBQ0wsT0FBT1AsU0FBU0ssT0FBT0MsVUFBVUMsZUFBZUMsVUFBVUM7WUFDNUQ7UUFDRjtRQUVBLElBQUlLLG1CQUFtQlgsVUFBVVksSUFBSSxDQUFDLE1BQU07UUFDNUNELGlCQUFpQlYsVUFBVSxHQUFHRCxVQUFVWSxJQUFJLENBQUMsTUFBTTtRQUVuRCxPQUFPRDtJQUNUO0lBRUEsU0FBU25ELDJCQUEyQnFELFlBQVk7UUFDOUMsU0FBU2hCLFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUVDLFFBQVEsRUFBRUMsWUFBWSxFQUFFQyxNQUFNO1lBQzlFLElBQUlPLFlBQVlaLEtBQUssQ0FBQ0MsU0FBUztZQUMvQixJQUFJWSxXQUFXQyxZQUFZRjtZQUMzQixJQUFJQyxhQUFhRixjQUFjO2dCQUM3QixxRUFBcUU7Z0JBQ3JFLHdFQUF3RTtnQkFDeEUsc0JBQXNCO2dCQUN0QixJQUFJSSxjQUFjQyxlQUFlSjtnQkFFakMsT0FBTyxJQUFJdEIsY0FDVCxhQUFhYSxXQUFXLE9BQU9DLGVBQWUsZUFBZ0IsT0FBTVcsY0FBYyxvQkFBb0JiLGdCQUFnQixjQUFhLElBQU0sT0FBTVMsZUFBZSxJQUFHLEdBQ2pLO29CQUFDQSxjQUFjQTtnQkFBWTtZQUUvQjtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU9qQiwyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBUzVCO1FBQ1AsT0FBTzJCLDJCQUEyQm5EO0lBQ3BDO0lBRUEsU0FBUzBCLHlCQUF5QmdELFdBQVc7UUFDM0MsU0FBU3RCLFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUVDLFFBQVEsRUFBRUMsWUFBWTtZQUN0RSxJQUFJLE9BQU9hLGdCQUFnQixZQUFZO2dCQUNyQyxPQUFPLElBQUkzQixjQUFjLGVBQWVjLGVBQWUscUJBQXFCRixnQkFBZ0I7WUFDOUY7WUFDQSxJQUFJVSxZQUFZWixLQUFLLENBQUNDLFNBQVM7WUFDL0IsSUFBSSxDQUFDaUIsTUFBTUMsT0FBTyxDQUFDUCxZQUFZO2dCQUM3QixJQUFJQyxXQUFXQyxZQUFZRjtnQkFDM0IsT0FBTyxJQUFJdEIsY0FBYyxhQUFhYSxXQUFXLE9BQU9DLGVBQWUsZUFBZ0IsT0FBTVMsV0FBVyxvQkFBb0JYLGdCQUFnQix1QkFBc0I7WUFDcEs7WUFDQSxJQUFLLElBQUlrQixJQUFJLEdBQUdBLElBQUlSLFVBQVVTLE1BQU0sRUFBRUQsSUFBSztnQkFDekMsSUFBSWhGLFFBQVE2RSxZQUFZTCxXQUFXUSxHQUFHbEIsZUFBZUMsVUFBVUMsZUFBZSxNQUFNZ0IsSUFBSSxLQUFLeEY7Z0JBQzdGLElBQUlRLGlCQUFpQkMsT0FBTztvQkFDMUIsT0FBT0Q7Z0JBQ1Q7WUFDRjtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU9zRCwyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBU3hCO1FBQ1AsU0FBU3dCLFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUVDLFFBQVEsRUFBRUMsWUFBWTtZQUN0RSxJQUFJUSxZQUFZWixLQUFLLENBQUNDLFNBQVM7WUFDL0IsSUFBSSxDQUFDdkQsZUFBZWtFLFlBQVk7Z0JBQzlCLElBQUlDLFdBQVdDLFlBQVlGO2dCQUMzQixPQUFPLElBQUl0QixjQUFjLGFBQWFhLFdBQVcsT0FBT0MsZUFBZSxlQUFnQixPQUFNUyxXQUFXLG9CQUFvQlgsZ0JBQWdCLG9DQUFtQztZQUNqTDtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU9SLDJCQUEyQkM7SUFDcEM7SUFFQSxTQUFTdEI7UUFDUCxTQUFTc0IsU0FBU0ssS0FBSyxFQUFFQyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsUUFBUSxFQUFFQyxZQUFZO1lBQ3RFLElBQUlRLFlBQVlaLEtBQUssQ0FBQ0MsU0FBUztZQUMvQixJQUFJLENBQUN4RSxRQUFRNkYsa0JBQWtCLENBQUNWLFlBQVk7Z0JBQzFDLElBQUlDLFdBQVdDLFlBQVlGO2dCQUMzQixPQUFPLElBQUl0QixjQUFjLGFBQWFhLFdBQVcsT0FBT0MsZUFBZSxlQUFnQixPQUFNUyxXQUFXLG9CQUFvQlgsZ0JBQWdCLHlDQUF3QztZQUN0TDtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU9SLDJCQUEyQkM7SUFDcEM7SUFFQSxTQUFTcEIsMEJBQTBCZ0QsYUFBYTtRQUM5QyxTQUFTNUIsU0FBU0ssS0FBSyxFQUFFQyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsUUFBUSxFQUFFQyxZQUFZO1lBQ3RFLElBQUksQ0FBRUosQ0FBQUEsS0FBSyxDQUFDQyxTQUFTLFlBQVlzQixhQUFZLEdBQUk7Z0JBQy9DLElBQUlDLG9CQUFvQkQsY0FBY2hCLElBQUksSUFBSXBEO2dCQUM5QyxJQUFJc0Usa0JBQWtCQyxhQUFhMUIsS0FBSyxDQUFDQyxTQUFTO2dCQUNsRCxPQUFPLElBQUlYLGNBQWMsYUFBYWEsV0FBVyxPQUFPQyxlQUFlLGVBQWdCLE9BQU1xQixrQkFBa0Isb0JBQW9CdkIsZ0JBQWdCLGNBQWEsSUFBTSxtQkFBa0JzQixvQkFBb0IsSUFBRztZQUNqTjtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU85QiwyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBU2Qsc0JBQXNCOEMsY0FBYztRQUMzQyxJQUFJLENBQUNULE1BQU1DLE9BQU8sQ0FBQ1EsaUJBQWlCO1lBQ2xDLElBQUkzRixJQUF5QixFQUFjO2dCQUN6QyxJQUFJNEYsVUFBVVAsTUFBTSxHQUFHLEdBQUc7b0JBQ3hCdEYsYUFDRSxpRUFBaUU2RixVQUFVUCxNQUFNLEdBQUcsaUJBQ3BGO2dCQUVKLE9BQU87b0JBQ0x0RixhQUFhO2dCQUNmO1lBQ0Y7WUFDQSxPQUFPUTtRQUNUO1FBRUEsU0FBU29ELFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUVDLFFBQVEsRUFBRUMsWUFBWTtZQUN0RSxJQUFJUSxZQUFZWixLQUFLLENBQUNDLFNBQVM7WUFDL0IsSUFBSyxJQUFJbUIsSUFBSSxHQUFHQSxJQUFJTyxlQUFlTixNQUFNLEVBQUVELElBQUs7Z0JBQzlDLElBQUloQyxHQUFHd0IsV0FBV2UsY0FBYyxDQUFDUCxFQUFFLEdBQUc7b0JBQ3BDLE9BQU87Z0JBQ1Q7WUFDRjtZQUVBLElBQUlTLGVBQWVDLEtBQUtDLFNBQVMsQ0FBQ0osZ0JBQWdCLFNBQVNLLFNBQVNDLEdBQUcsRUFBRUMsS0FBSztnQkFDNUUsSUFBSUMsT0FBT25CLGVBQWVrQjtnQkFDMUIsSUFBSUMsU0FBUyxVQUFVO29CQUNyQixPQUFPQyxPQUFPRjtnQkFDaEI7Z0JBQ0EsT0FBT0E7WUFDVDtZQUNBLE9BQU8sSUFBSTVDLGNBQWMsYUFBYWEsV0FBVyxPQUFPQyxlQUFlLGlCQUFpQmdDLE9BQU94QixhQUFhLE9BQVEsbUJBQWtCVixnQkFBZ0Isd0JBQXdCMkIsZUFBZSxHQUFFO1FBQ2pNO1FBQ0EsT0FBT25DLDJCQUEyQkM7SUFDcEM7SUFFQSxTQUFTaEIsMEJBQTBCc0MsV0FBVztRQUM1QyxTQUFTdEIsU0FBU0ssS0FBSyxFQUFFQyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsUUFBUSxFQUFFQyxZQUFZO1lBQ3RFLElBQUksT0FBT2EsZ0JBQWdCLFlBQVk7Z0JBQ3JDLE9BQU8sSUFBSTNCLGNBQWMsZUFBZWMsZUFBZSxxQkFBcUJGLGdCQUFnQjtZQUM5RjtZQUNBLElBQUlVLFlBQVlaLEtBQUssQ0FBQ0MsU0FBUztZQUMvQixJQUFJWSxXQUFXQyxZQUFZRjtZQUMzQixJQUFJQyxhQUFhLFVBQVU7Z0JBQ3pCLE9BQU8sSUFBSXZCLGNBQWMsYUFBYWEsV0FBVyxPQUFPQyxlQUFlLGVBQWdCLE9BQU1TLFdBQVcsb0JBQW9CWCxnQkFBZ0Isd0JBQXVCO1lBQ3JLO1lBQ0EsSUFBSyxJQUFJK0IsT0FBT3JCLFVBQVc7Z0JBQ3pCLElBQUkvRSxJQUFJK0UsV0FBV3FCLE1BQU07b0JBQ3ZCLElBQUk3RixRQUFRNkUsWUFBWUwsV0FBV3FCLEtBQUsvQixlQUFlQyxVQUFVQyxlQUFlLE1BQU02QixLQUFLckc7b0JBQzNGLElBQUlRLGlCQUFpQkMsT0FBTzt3QkFDMUIsT0FBT0Q7b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU9zRCwyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBU1osdUJBQXVCc0QsbUJBQW1CO1FBQ2pELElBQUksQ0FBQ25CLE1BQU1DLE9BQU8sQ0FBQ2tCLHNCQUFzQjtZQWhYN0MsS0FpWCtCLEdBQWV0RyxhQUFhLDRFQUE0RSxDQUFNO1lBQ3ZJLE9BQU9RO1FBQ1Q7UUFFQSxJQUFLLElBQUk2RSxJQUFJLEdBQUdBLElBQUlpQixvQkFBb0JoQixNQUFNLEVBQUVELElBQUs7WUFDbkQsSUFBSWtCLFVBQVVELG1CQUFtQixDQUFDakIsRUFBRTtZQUNwQyxJQUFJLE9BQU9rQixZQUFZLFlBQVk7Z0JBQ2pDdkcsYUFDRSx1RkFDQSxjQUFjd0cseUJBQXlCRCxXQUFXLGVBQWVsQixJQUFJO2dCQUV2RSxPQUFPN0U7WUFDVDtRQUNGO1FBRUEsU0FBU29ELFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUVDLFFBQVEsRUFBRUMsWUFBWTtZQUN0RSxJQUFJb0MsZ0JBQWdCLEVBQUU7WUFDdEIsSUFBSyxJQUFJcEIsSUFBSSxHQUFHQSxJQUFJaUIsb0JBQW9CaEIsTUFBTSxFQUFFRCxJQUFLO2dCQUNuRCxJQUFJa0IsVUFBVUQsbUJBQW1CLENBQUNqQixFQUFFO2dCQUNwQyxJQUFJcUIsZ0JBQWdCSCxRQUFRdEMsT0FBT0MsVUFBVUMsZUFBZUMsVUFBVUMsY0FBY3hFO2dCQUNwRixJQUFJNkcsaUJBQWlCLE1BQU07b0JBQ3pCLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSUEsY0FBY2xELElBQUksSUFBSTFELElBQUk0RyxjQUFjbEQsSUFBSSxFQUFFLGlCQUFpQjtvQkFDakVpRCxjQUFjRSxJQUFJLENBQUNELGNBQWNsRCxJQUFJLENBQUNvQixZQUFZO2dCQUNwRDtZQUNGO1lBQ0EsSUFBSWdDLHVCQUF1QixjQUFldEIsTUFBTSxHQUFHLElBQUssNkJBQTZCbUIsY0FBY0ksSUFBSSxDQUFDLFFBQVEsTUFBSztZQUNySCxPQUFPLElBQUl0RCxjQUFjLGFBQWFhLFdBQVcsT0FBT0MsZUFBZSxtQkFBb0IsT0FBTUYsZ0JBQWdCLE1BQU15Qyx1QkFBdUIsR0FBRTtRQUNsSjtRQUNBLE9BQU9qRCwyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBU2xCO1FBQ1AsU0FBU2tCLFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUVDLFFBQVEsRUFBRUMsWUFBWTtZQUN0RSxJQUFJLENBQUN5QyxPQUFPN0MsS0FBSyxDQUFDQyxTQUFTLEdBQUc7Z0JBQzVCLE9BQU8sSUFBSVgsY0FBYyxhQUFhYSxXQUFXLE9BQU9DLGVBQWUsbUJBQW9CLE9BQU1GLGdCQUFnQiwwQkFBeUI7WUFDNUk7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxPQUFPUiwyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBU21ELHNCQUFzQjVDLGFBQWEsRUFBRUMsUUFBUSxFQUFFQyxZQUFZLEVBQUU2QixHQUFHLEVBQUVFLElBQUk7UUFDN0UsT0FBTyxJQUFJN0MsY0FDVCxDQUFDWSxpQkFBaUIsYUFBWSxJQUFLLE9BQU9DLFdBQVcsWUFBWUMsZUFBZSxNQUFNNkIsTUFBTSxtQkFDNUYsaUZBQWlGRSxPQUFPO0lBRTVGO0lBRUEsU0FBU2xELHVCQUF1QjhELFVBQVU7UUFDeEMsU0FBU3BELFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUVDLFFBQVEsRUFBRUMsWUFBWTtZQUN0RSxJQUFJUSxZQUFZWixLQUFLLENBQUNDLFNBQVM7WUFDL0IsSUFBSVksV0FBV0MsWUFBWUY7WUFDM0IsSUFBSUMsYUFBYSxVQUFVO2dCQUN6QixPQUFPLElBQUl2QixjQUFjLGFBQWFhLFdBQVcsT0FBT0MsZUFBZSxnQkFBZ0JTLFdBQVcsT0FBUSxtQkFBa0JYLGdCQUFnQix1QkFBc0I7WUFDcEs7WUFDQSxJQUFLLElBQUkrQixPQUFPYyxXQUFZO2dCQUMxQixJQUFJVCxVQUFVUyxVQUFVLENBQUNkLElBQUk7Z0JBQzdCLElBQUksT0FBT0ssWUFBWSxZQUFZO29CQUNqQyxPQUFPUSxzQkFBc0I1QyxlQUFlQyxVQUFVQyxjQUFjNkIsS0FBS2pCLGVBQWVzQjtnQkFDMUY7Z0JBQ0EsSUFBSWxHLFFBQVFrRyxRQUFRMUIsV0FBV3FCLEtBQUsvQixlQUFlQyxVQUFVQyxlQUFlLE1BQU02QixLQUFLckc7Z0JBQ3ZGLElBQUlRLE9BQU87b0JBQ1QsT0FBT0E7Z0JBQ1Q7WUFDRjtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU9zRCwyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBU1IsNkJBQTZCNEQsVUFBVTtRQUM5QyxTQUFTcEQsU0FBU0ssS0FBSyxFQUFFQyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsUUFBUSxFQUFFQyxZQUFZO1lBQ3RFLElBQUlRLFlBQVlaLEtBQUssQ0FBQ0MsU0FBUztZQUMvQixJQUFJWSxXQUFXQyxZQUFZRjtZQUMzQixJQUFJQyxhQUFhLFVBQVU7Z0JBQ3pCLE9BQU8sSUFBSXZCLGNBQWMsYUFBYWEsV0FBVyxPQUFPQyxlQUFlLGdCQUFnQlMsV0FBVyxPQUFRLG1CQUFrQlgsZ0JBQWdCLHVCQUFzQjtZQUNwSztZQUNBLDhFQUE4RTtZQUM5RSxJQUFJOEMsVUFBVXJILE9BQU8sQ0FBQyxHQUFHcUUsS0FBSyxDQUFDQyxTQUFTLEVBQUU4QztZQUMxQyxJQUFLLElBQUlkLE9BQU9lLFFBQVM7Z0JBQ3ZCLElBQUlWLFVBQVVTLFVBQVUsQ0FBQ2QsSUFBSTtnQkFDN0IsSUFBSXBHLElBQUlrSCxZQUFZZCxRQUFRLE9BQU9LLFlBQVksWUFBWTtvQkFDekQsT0FBT1Esc0JBQXNCNUMsZUFBZUMsVUFBVUMsY0FBYzZCLEtBQUtqQixlQUFlc0I7Z0JBQzFGO2dCQUNBLElBQUksQ0FBQ0EsU0FBUztvQkFDWixPQUFPLElBQUloRCxjQUNULGFBQWFhLFdBQVcsT0FBT0MsZUFBZSxZQUFZNkIsTUFBTSxvQkFBb0IvQixnQkFBZ0IsT0FDcEcsbUJBQW1CNEIsS0FBS0MsU0FBUyxDQUFDL0IsS0FBSyxDQUFDQyxTQUFTLEVBQUUsTUFBTSxRQUN6RCxtQkFBbUI2QixLQUFLQyxTQUFTLENBQUNrQixPQUFPQyxJQUFJLENBQUNILGFBQWEsTUFBTTtnQkFFckU7Z0JBQ0EsSUFBSTNHLFFBQVFrRyxRQUFRMUIsV0FBV3FCLEtBQUsvQixlQUFlQyxVQUFVQyxlQUFlLE1BQU02QixLQUFLckc7Z0JBQ3ZGLElBQUlRLE9BQU87b0JBQ1QsT0FBT0E7Z0JBQ1Q7WUFDRjtZQUNBLE9BQU87UUFDVDtRQUVBLE9BQU9zRCwyQkFBMkJDO0lBQ3BDO0lBRUEsU0FBU2tELE9BQU9qQyxTQUFTO1FBQ3ZCLE9BQVEsT0FBT0E7WUFDYixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTyxDQUFDQTtZQUNWLEtBQUs7Z0JBQ0gsSUFBSU0sTUFBTUMsT0FBTyxDQUFDUCxZQUFZO29CQUM1QixPQUFPQSxVQUFVdUMsS0FBSyxDQUFDTjtnQkFDekI7Z0JBQ0EsSUFBSWpDLGNBQWMsUUFBUWxFLGVBQWVrRSxZQUFZO29CQUNuRCxPQUFPO2dCQUNUO2dCQUVBLElBQUkxRCxhQUFhRixjQUFjNEQ7Z0JBQy9CLElBQUkxRCxZQUFZO29CQUNkLElBQUlKLFdBQVdJLFdBQVdrRyxJQUFJLENBQUN4QztvQkFDL0IsSUFBSXlDO29CQUNKLElBQUluRyxlQUFlMEQsVUFBVTBDLE9BQU8sRUFBRTt3QkFDcEMsTUFBTyxDQUFDLENBQUNELE9BQU92RyxTQUFTeUcsSUFBSSxFQUFDLEVBQUdDLElBQUksQ0FBRTs0QkFDckMsSUFBSSxDQUFDWCxPQUFPUSxLQUFLbkIsS0FBSyxHQUFHO2dDQUN2QixPQUFPOzRCQUNUO3dCQUNGO29CQUNGLE9BQU87d0JBQ0wsK0RBQStEO3dCQUMvRCxNQUFPLENBQUMsQ0FBQ21CLE9BQU92RyxTQUFTeUcsSUFBSSxFQUFDLEVBQUdDLElBQUksQ0FBRTs0QkFDckMsSUFBSUMsUUFBUUosS0FBS25CLEtBQUs7NEJBQ3RCLElBQUl1QixPQUFPO2dDQUNULElBQUksQ0FBQ1osT0FBT1ksS0FBSyxDQUFDLEVBQUUsR0FBRztvQ0FDckIsT0FBTztnQ0FDVDs0QkFDRjt3QkFDRjtvQkFDRjtnQkFDRixPQUFPO29CQUNMLE9BQU87Z0JBQ1Q7Z0JBRUEsT0FBTztZQUNUO2dCQUNFLE9BQU87UUFDWDtJQUNGO0lBRUEsU0FBU0MsU0FBUzdDLFFBQVEsRUFBRUQsU0FBUztRQUNuQyxpQkFBaUI7UUFDakIsSUFBSUMsYUFBYSxVQUFVO1lBQ3pCLE9BQU87UUFDVDtRQUVBLGdDQUFnQztRQUNoQyxJQUFJLENBQUNELFdBQVc7WUFDZCxPQUFPO1FBQ1Q7UUFFQSx3REFBd0Q7UUFDeEQsSUFBSUEsU0FBUyxDQUFDLGdCQUFnQixLQUFLLFVBQVU7WUFDM0MsT0FBTztRQUNUO1FBRUEsZ0VBQWdFO1FBQ2hFLElBQUksT0FBTy9ELFdBQVcsY0FBYytELHFCQUFxQi9ELFFBQVE7WUFDL0QsT0FBTztRQUNUO1FBRUEsT0FBTztJQUNUO0lBRUEseUVBQXlFO0lBQ3pFLFNBQVNpRSxZQUFZRixTQUFTO1FBQzVCLElBQUlDLFdBQVcsT0FBT0Q7UUFDdEIsSUFBSU0sTUFBTUMsT0FBTyxDQUFDUCxZQUFZO1lBQzVCLE9BQU87UUFDVDtRQUNBLElBQUlBLHFCQUFxQitDLFFBQVE7WUFDL0IseUVBQXlFO1lBQ3pFLHdFQUF3RTtZQUN4RSwyQkFBMkI7WUFDM0IsT0FBTztRQUNUO1FBQ0EsSUFBSUQsU0FBUzdDLFVBQVVELFlBQVk7WUFDakMsT0FBTztRQUNUO1FBQ0EsT0FBT0M7SUFDVDtJQUVBLDRFQUE0RTtJQUM1RSxvQ0FBb0M7SUFDcEMsU0FBU0csZUFBZUosU0FBUztRQUMvQixJQUFJLE9BQU9BLGNBQWMsZUFBZUEsY0FBYyxNQUFNO1lBQzFELE9BQU8sS0FBS0E7UUFDZDtRQUNBLElBQUlDLFdBQVdDLFlBQVlGO1FBQzNCLElBQUlDLGFBQWEsVUFBVTtZQUN6QixJQUFJRCxxQkFBcUJnRCxNQUFNO2dCQUM3QixPQUFPO1lBQ1QsT0FBTyxJQUFJaEQscUJBQXFCK0MsUUFBUTtnQkFDdEMsT0FBTztZQUNUO1FBQ0Y7UUFDQSxPQUFPOUM7SUFDVDtJQUVBLHlFQUF5RTtJQUN6RSw4Q0FBOEM7SUFDOUMsU0FBUzBCLHlCQUF5QkwsS0FBSztRQUNyQyxJQUFJQyxPQUFPbkIsZUFBZWtCO1FBQzFCLE9BQVFDO1lBQ04sS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBTyxRQUFRQTtZQUNqQixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBTyxPQUFPQTtZQUNoQjtnQkFDRSxPQUFPQTtRQUNYO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsU0FBU1QsYUFBYWQsU0FBUztRQUM3QixJQUFJLENBQUNBLFVBQVVpRCxXQUFXLElBQUksQ0FBQ2pELFVBQVVpRCxXQUFXLENBQUN0RCxJQUFJLEVBQUU7WUFDekQsT0FBT3BEO1FBQ1Q7UUFDQSxPQUFPeUQsVUFBVWlELFdBQVcsQ0FBQ3RELElBQUk7SUFDbkM7SUFFQW5ELGVBQWV0QixjQUFjLEdBQUdBO0lBQ2hDc0IsZUFBZTBHLGlCQUFpQixHQUFHaEksZUFBZWdJLGlCQUFpQjtJQUNuRTFHLGVBQWUyRyxTQUFTLEdBQUczRztJQUUzQixPQUFPQTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BzdHJpcGUvcmVhY3Qtc3RyaXBlLWpzL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzPzA2NzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSxcbiAgICAgICAgICB7ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGV9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIHZhciBjaGVja2VyUmVzdWx0ID0gY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0LmRhdGEgJiYgaGFzKGNoZWNrZXJSZXN1bHQuZGF0YSwgJ2V4cGVjdGVkVHlwZScpKSB7XG4gICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGNoZWNrZXJSZXN1bHQuZGF0YS5leHBlY3RlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgPSAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwKSA/ICcsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFsnICsgZXhwZWN0ZWRUeXBlcy5qb2luKCcsICcpICsgJ10nOiAnJztcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AnICsgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHByb3BGdWxsTmFtZSArICcuJyArIGtleSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZSArICdgLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb20gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoaGFzKHNoYXBlVHlwZXMsIGtleSkgJiYgdHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0SXMiLCJyZXF1aXJlIiwiYXNzaWduIiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJoYXMiLCJjaGVja1Byb3BUeXBlcyIsInByaW50V2FybmluZyIsInByb2Nlc3MiLCJ0ZXh0IiwibWVzc2FnZSIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwieCIsImVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwiLCJtb2R1bGUiLCJleHBvcnRzIiwiaXNWYWxpZEVsZW1lbnQiLCJ0aHJvd09uRGlyZWN0QWNjZXNzIiwiSVRFUkFUT1JfU1lNQk9MIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsIkFOT05ZTU9VUyIsIlJlYWN0UHJvcFR5cGVzIiwiYXJyYXkiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsImJpZ2ludCIsImJvb2wiLCJmdW5jIiwibnVtYmVyIiwib2JqZWN0Iiwic3RyaW5nIiwic3ltYm9sIiwiYW55IiwiY3JlYXRlQW55VHlwZUNoZWNrZXIiLCJhcnJheU9mIiwiY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyIiwiZWxlbWVudCIsImNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlciIsImVsZW1lbnRUeXBlIiwiY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlciIsImluc3RhbmNlT2YiLCJjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyIiwibm9kZSIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJvbmVPZlR5cGUiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwic2hhcGUiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiZXhhY3QiLCJjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyIiwiaXMiLCJ5IiwiUHJvcFR5cGVFcnJvciIsImRhdGEiLCJzdGFjayIsInByb3RvdHlwZSIsImNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyIiwidmFsaWRhdGUiLCJtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSIsIm1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IiwiY2hlY2tUeXBlIiwiaXNSZXF1aXJlZCIsInByb3BzIiwicHJvcE5hbWUiLCJjb21wb25lbnROYW1lIiwibG9jYXRpb24iLCJwcm9wRnVsbE5hbWUiLCJzZWNyZXQiLCJlcnIiLCJuYW1lIiwiY2FjaGVLZXkiLCJjaGFpbmVkQ2hlY2tUeXBlIiwiYmluZCIsImV4cGVjdGVkVHlwZSIsInByb3BWYWx1ZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJBcnJheSIsImlzQXJyYXkiLCJpIiwibGVuZ3RoIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZXhwZWN0ZWRDbGFzcyIsImV4cGVjdGVkQ2xhc3NOYW1lIiwiYWN0dWFsQ2xhc3NOYW1lIiwiZ2V0Q2xhc3NOYW1lIiwiZXhwZWN0ZWRWYWx1ZXMiLCJhcmd1bWVudHMiLCJ2YWx1ZXNTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwicmVwbGFjZXIiLCJrZXkiLCJ2YWx1ZSIsInR5cGUiLCJTdHJpbmciLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImdldFBvc3RmaXhGb3JUeXBlV2FybmluZyIsImV4cGVjdGVkVHlwZXMiLCJjaGVja2VyUmVzdWx0IiwicHVzaCIsImV4cGVjdGVkVHlwZXNNZXNzYWdlIiwiam9pbiIsImlzTm9kZSIsImludmFsaWRWYWxpZGF0b3JFcnJvciIsInNoYXBlVHlwZXMiLCJhbGxLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImV2ZXJ5IiwiY2FsbCIsInN0ZXAiLCJlbnRyaWVzIiwibmV4dCIsImRvbmUiLCJlbnRyeSIsImlzU3ltYm9sIiwiUmVnRXhwIiwiRGF0ZSIsImNvbnN0cnVjdG9yIiwicmVzZXRXYXJuaW5nQ2FjaGUiLCJQcm9wVHlwZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/factoryWithTypeCheckers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/node_modules/prop-types/index.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    var ReactIs = __webpack_require__(/*! react-is */ \"(ssr)/./node_modules/react-is/index.js\");\n    // By explicitly using `prop-types` you are opting into new development behavior.\n    // http://fb.me/prop-types-in-prod\n    var throwOnDirectAccess = true;\n    module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7QUFFRCxJQUFJQSxJQUF5QixFQUFjO0lBQ3pDLElBQUlDLFVBQVVDLG1CQUFPQSxDQUFDO0lBRXRCLGlGQUFpRjtJQUNqRixrQ0FBa0M7SUFDbEMsSUFBSUMsc0JBQXNCO0lBQzFCQyxPQUFPQyxPQUFPLEdBQUdILG1CQUFPQSxDQUFDLG9JQUE2QkQsUUFBUUssU0FBUyxFQUFFSDtBQUMzRSxPQUFPLEVBSU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanM/MjBjYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIlJlYWN0SXMiLCJyZXF1aXJlIiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJpc0VsZW1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \**************************************************************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nvar ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDLEdBRUQ7QUFFQSxJQUFJQSx1QkFBdUI7QUFFM0JDLE9BQU9DLE9BQU8sR0FBR0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzP2E3NTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwibmFtZXMiOlsiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/lib/ReactPropTypesSecret.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/lib/has.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/node_modules/prop-types/lib/has.js ***!
  \*********************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL2hhcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLE9BQU9DLE9BQU8sR0FBR0MsU0FBU0MsSUFBSSxDQUFDQyxJQUFJLENBQUNDLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3RyaXBlL3JlYWN0LXN0cmlwZS1qcy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzPzgzNjkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkZ1bmN0aW9uIiwiY2FsbCIsImJpbmQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/node_modules/prop-types/lib/has.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/stripe-js/dist/pure.js":
/*!*****************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/dist/pure.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nvar V3_URL = \"https://js.stripe.com/v3\";\nvar V3_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/v3\\/?(\\?.*)?$/;\nvar EXISTING_SCRIPT_MESSAGE = \"loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used\";\nvar findScript = function findScript() {\n    var scripts = document.querySelectorAll('script[src^=\"'.concat(V3_URL, '\"]'));\n    for(var i = 0; i < scripts.length; i++){\n        var script = scripts[i];\n        if (!V3_URL_REGEX.test(script.src)) {\n            continue;\n        }\n        return script;\n    }\n    return null;\n};\nvar injectScript = function injectScript(params) {\n    var queryString = params && !params.advancedFraudSignals ? \"?advancedFraudSignals=false\" : \"\";\n    var script = document.createElement(\"script\");\n    script.src = \"\".concat(V3_URL).concat(queryString);\n    var headOrBody = document.head || document.body;\n    if (!headOrBody) {\n        throw new Error(\"Expected document.body not to be null. Stripe.js requires a <body> element.\");\n    }\n    headOrBody.appendChild(script);\n    return script;\n};\nvar registerWrapper = function registerWrapper(stripe, startTime) {\n    if (!stripe || !stripe._registerWrapper) {\n        return;\n    }\n    stripe._registerWrapper({\n        name: \"stripe-js\",\n        version: \"1.54.2\",\n        startTime: startTime\n    });\n};\nvar stripePromise = null;\nvar loadScript = function loadScript(params) {\n    // Ensure that we only attempt to load Stripe.js at most once\n    if (stripePromise !== null) {\n        return stripePromise;\n    }\n    stripePromise = new Promise(function(resolve, reject) {\n        if (true) {\n            // Resolve to null when imported server side. This makes the module\n            // safe to import in an isomorphic code base.\n            resolve(null);\n            return;\n        }\n        if (window.Stripe && params) {\n            console.warn(EXISTING_SCRIPT_MESSAGE);\n        }\n        if (window.Stripe) {\n            resolve(window.Stripe);\n            return;\n        }\n        try {\n            var script = findScript();\n            if (script && params) {\n                console.warn(EXISTING_SCRIPT_MESSAGE);\n            } else if (!script) {\n                script = injectScript(params);\n            }\n            script.addEventListener(\"load\", function() {\n                if (window.Stripe) {\n                    resolve(window.Stripe);\n                } else {\n                    reject(new Error(\"Stripe.js not available\"));\n                }\n            });\n            script.addEventListener(\"error\", function() {\n                reject(new Error(\"Failed to load Stripe.js\"));\n            });\n        } catch (error) {\n            reject(error);\n            return;\n        }\n    });\n    return stripePromise;\n};\nvar initStripe = function initStripe(maybeStripe, args, startTime) {\n    if (maybeStripe === null) {\n        return null;\n    }\n    var stripe = maybeStripe.apply(undefined, args);\n    registerWrapper(stripe, startTime);\n    return stripe;\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nvar validateLoadParams = function validateLoadParams(params) {\n    var errorMessage = \"invalid load parameters; expected object of shape\\n\\n    {advancedFraudSignals: boolean}\\n\\nbut received\\n\\n    \".concat(JSON.stringify(params), \"\\n\");\n    if (params === null || _typeof(params) !== \"object\") {\n        throw new Error(errorMessage);\n    }\n    if (Object.keys(params).length === 1 && typeof params.advancedFraudSignals === \"boolean\") {\n        return params;\n    }\n    throw new Error(errorMessage);\n};\nvar loadParams;\nvar loadStripeCalled = false;\nvar loadStripe = function loadStripe() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    loadStripeCalled = true;\n    var startTime = Date.now();\n    return loadScript(loadParams).then(function(maybeStripe) {\n        return initStripe(maybeStripe, args, startTime);\n    });\n};\nloadStripe.setLoadParameters = function(params) {\n    // we won't throw an error if setLoadParameters is called with the same values as before\n    if (loadStripeCalled && loadParams) {\n        var validatedParams = validateLoadParams(params);\n        var parameterKeys = Object.keys(validatedParams);\n        var sameParameters = parameterKeys.reduce(function(previousValue, currentValue) {\n            var _loadParams;\n            return previousValue && params[currentValue] === ((_loadParams = loadParams) === null || _loadParams === void 0 ? void 0 : _loadParams[currentValue]);\n        }, true);\n        if (sameParameters) {\n            return;\n        }\n    }\n    if (loadStripeCalled) {\n        throw new Error(\"You cannot change load parameters after calling loadStripe\");\n    }\n    loadParams = validateLoadParams(params);\n};\nexports.loadStripe = loadStripe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvZGlzdC9wdXJlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELFNBQVNDLFFBQVFDLEdBQUc7SUFDbEI7SUFFQSxJQUFJLE9BQU9DLFdBQVcsY0FBYyxPQUFPQSxPQUFPQyxRQUFRLEtBQUssVUFBVTtRQUN2RUgsVUFBVSxTQUFVQyxHQUFHO1lBQ3JCLE9BQU8sT0FBT0E7UUFDaEI7SUFDRixPQUFPO1FBQ0xELFVBQVUsU0FBVUMsR0FBRztZQUNyQixPQUFPQSxPQUFPLE9BQU9DLFdBQVcsY0FBY0QsSUFBSUcsV0FBVyxLQUFLRixVQUFVRCxRQUFRQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtRQUMzSDtJQUNGO0lBRUEsT0FBT0QsUUFBUUM7QUFDakI7QUFFQSxJQUFJSyxTQUFTO0FBQ2IsSUFBSUMsZUFBZTtBQUNuQixJQUFJQywwQkFBMEI7QUFDOUIsSUFBSUMsYUFBYSxTQUFTQTtJQUN4QixJQUFJQyxVQUFVQyxTQUFTQyxnQkFBZ0IsQ0FBQyxnQkFBaUJDLE1BQU0sQ0FBQ1AsUUFBUTtJQUV4RSxJQUFLLElBQUlRLElBQUksR0FBR0EsSUFBSUosUUFBUUssTUFBTSxFQUFFRCxJQUFLO1FBQ3ZDLElBQUlFLFNBQVNOLE9BQU8sQ0FBQ0ksRUFBRTtRQUV2QixJQUFJLENBQUNQLGFBQWFVLElBQUksQ0FBQ0QsT0FBT0UsR0FBRyxHQUFHO1lBQ2xDO1FBQ0Y7UUFFQSxPQUFPRjtJQUNUO0lBRUEsT0FBTztBQUNUO0FBRUEsSUFBSUcsZUFBZSxTQUFTQSxhQUFhQyxNQUFNO0lBQzdDLElBQUlDLGNBQWNELFVBQVUsQ0FBQ0EsT0FBT0Usb0JBQW9CLEdBQUcsZ0NBQWdDO0lBQzNGLElBQUlOLFNBQVNMLFNBQVNZLGFBQWEsQ0FBQztJQUNwQ1AsT0FBT0UsR0FBRyxHQUFHLEdBQUdMLE1BQU0sQ0FBQ1AsUUFBUU8sTUFB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b0IsWUFBWVMsSUFBSSxDQUFDLFNBQVVsQixXQUFXO1FBQ3RELE9BQU9ELFdBQVdDLGFBQWFDLE1BQU1qQjtJQUN2QztBQUNGO0FBRUEyQixXQUFXUSxpQkFBaUIsR0FBRyxTQUFVOUMsTUFBTTtJQUM3Qyx3RkFBd0Y7SUFDeEYsSUFBSXFDLG9CQUFvQkQsWUFBWTtRQUNsQyxJQUFJVyxrQkFBa0JoQixtQkFBbUIvQjtRQUN6QyxJQUFJZ0QsZ0JBQWdCeEUsT0FBTzJELElBQUksQ0FBQ1k7UUFDaEMsSUFBSUUsaUJBQWlCRCxjQUFjRSxNQUFNLENBQUMsU0FBVUMsYUFBYSxFQUFFQyxZQUFZO1lBQzdFLElBQUlDO1lBRUosT0FBT0YsaUJBQWlCbkQsTUFBTSxDQUFDb0QsYUFBYSxLQUFNLEVBQUNDLGNBQWNqQixVQUFTLE1BQU8sUUFBUWlCLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXLENBQUNELGFBQWE7UUFDdEosR0FBRztRQUVILElBQUlILGdCQUFnQjtZQUNsQjtRQUNGO0lBQ0Y7SUFFQSxJQUFJWixrQkFBa0I7UUFDcEIsTUFBTSxJQUFJOUIsTUFBTTtJQUNsQjtJQUVBNkIsYUFBYUwsbUJBQW1CL0I7QUFDbEM7QUFFQXRCLGtCQUFrQixHQUFHNEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvZGlzdC9wdXJlLmpzPzk3NTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG52YXIgVjNfVVJMID0gJ2h0dHBzOi8vanMuc3RyaXBlLmNvbS92Myc7XG52YXIgVjNfVVJMX1JFR0VYID0gL15odHRwczpcXC9cXC9qc1xcLnN0cmlwZVxcLmNvbVxcL3YzXFwvPyhcXD8uKik/JC87XG52YXIgRVhJU1RJTkdfU0NSSVBUX01FU1NBR0UgPSAnbG9hZFN0cmlwZS5zZXRMb2FkUGFyYW1ldGVycyB3YXMgY2FsbGVkIGJ1dCBhbiBleGlzdGluZyBTdHJpcGUuanMgc2NyaXB0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBkb2N1bWVudDsgZXhpc3Rpbmcgc2NyaXB0IHBhcmFtZXRlcnMgd2lsbCBiZSB1c2VkJztcbnZhciBmaW5kU2NyaXB0ID0gZnVuY3Rpb24gZmluZFNjcmlwdCgpIHtcbiAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic2NyaXB0W3NyY149XFxcIlwiLmNvbmNhdChWM19VUkwsIFwiXFxcIl1cIikpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzY3JpcHQgPSBzY3JpcHRzW2ldO1xuXG4gICAgaWYgKCFWM19VUkxfUkVHRVgudGVzdChzY3JpcHQuc3JjKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcmlwdDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIGluamVjdFNjcmlwdCA9IGZ1bmN0aW9uIGluamVjdFNjcmlwdChwYXJhbXMpIHtcbiAgdmFyIHF1ZXJ5U3RyaW5nID0gcGFyYW1zICYmICFwYXJhbXMuYWR2YW5jZWRGcmF1ZFNpZ25hbHMgPyAnP2FkdmFuY2VkRnJhdWRTaWduYWxzPWZhbHNlJyA6ICcnO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC5zcmMgPSBcIlwiLmNvbmNhdChWM19VUkwpLmNvbmNhdChxdWVyeVN0cmluZyk7XG4gIHZhciBoZWFkT3JCb2R5ID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5O1xuXG4gIGlmICghaGVhZE9yQm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZG9jdW1lbnQuYm9keSBub3QgdG8gYmUgbnVsbC4gU3RyaXBlLmpzIHJlcXVpcmVzIGEgPGJvZHk+IGVsZW1lbnQuJyk7XG4gIH1cblxuICBoZWFkT3JCb2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIHJldHVybiBzY3JpcHQ7XG59O1xuXG52YXIgcmVnaXN0ZXJXcmFwcGVyID0gZnVuY3Rpb24gcmVnaXN0ZXJXcmFwcGVyKHN0cmlwZSwgc3RhcnRUaW1lKSB7XG4gIGlmICghc3RyaXBlIHx8ICFzdHJpcGUuX3JlZ2lzdGVyV3JhcHBlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyKHtcbiAgICBuYW1lOiAnc3RyaXBlLWpzJyxcbiAgICB2ZXJzaW9uOiBcIjEuNTQuMlwiLFxuICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lXG4gIH0pO1xufTtcblxudmFyIHN0cmlwZVByb21pc2UgPSBudWxsO1xudmFyIGxvYWRTY3JpcHQgPSBmdW5jdGlvbiBsb2FkU2NyaXB0KHBhcmFtcykge1xuICAvLyBFbnN1cmUgdGhhdCB3ZSBvbmx5IGF0dGVtcHQgdG8gbG9hZCBTdHJpcGUuanMgYXQgbW9zdCBvbmNlXG4gIGlmIChzdHJpcGVQcm9taXNlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHN0cmlwZVByb21pc2U7XG4gIH1cblxuICBzdHJpcGVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBSZXNvbHZlIHRvIG51bGwgd2hlbiBpbXBvcnRlZCBzZXJ2ZXIgc2lkZS4gVGhpcyBtYWtlcyB0aGUgbW9kdWxlXG4gICAgICAvLyBzYWZlIHRvIGltcG9ydCBpbiBhbiBpc29tb3JwaGljIGNvZGUgYmFzZS5cbiAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5TdHJpcGUgJiYgcGFyYW1zKSB7XG4gICAgICBjb25zb2xlLndhcm4oRVhJU1RJTkdfU0NSSVBUX01FU1NBR0UpO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuU3RyaXBlKSB7XG4gICAgICByZXNvbHZlKHdpbmRvdy5TdHJpcGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgc2NyaXB0ID0gZmluZFNjcmlwdCgpO1xuXG4gICAgICBpZiAoc2NyaXB0ICYmIHBhcmFtcykge1xuICAgICAgICBjb25zb2xlLndhcm4oRVhJU1RJTkdfU0NSSVBUX01FU1NBR0UpO1xuICAgICAgfSBlbHNlIGlmICghc2NyaXB0KSB7XG4gICAgICAgIHNjcmlwdCA9IGluamVjdFNjcmlwdChwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5TdHJpcGUpIHtcbiAgICAgICAgICByZXNvbHZlKHdpbmRvdy5TdHJpcGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1N0cmlwZS5qcyBub3QgYXZhaWxhYmxlJykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgU3RyaXBlLmpzJykpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0cmlwZVByb21pc2U7XG59O1xudmFyIGluaXRTdHJpcGUgPSBmdW5jdGlvbiBpbml0U3RyaXBlKG1heWJlU3RyaXBlLCBhcmdzLCBzdGFydFRpbWUpIHtcbiAgaWYgKG1heWJlU3RyaXBlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc3RyaXBlID0gbWF5YmVTdHJpcGUuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgcmVnaXN0ZXJXcmFwcGVyKHN0cmlwZSwgc3RhcnRUaW1lKTtcbiAgcmV0dXJuIHN0cmlwZTtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5cbnZhciB2YWxpZGF0ZUxvYWRQYXJhbXMgPSBmdW5jdGlvbiB2YWxpZGF0ZUxvYWRQYXJhbXMocGFyYW1zKSB7XG4gIHZhciBlcnJvck1lc3NhZ2UgPSBcImludmFsaWQgbG9hZCBwYXJhbWV0ZXJzOyBleHBlY3RlZCBvYmplY3Qgb2Ygc2hhcGVcXG5cXG4gICAge2FkdmFuY2VkRnJhdWRTaWduYWxzOiBib29sZWFufVxcblxcbmJ1dCByZWNlaXZlZFxcblxcbiAgICBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkocGFyYW1zKSwgXCJcXG5cIik7XG5cbiAgaWYgKHBhcmFtcyA9PT0gbnVsbCB8fCBfdHlwZW9mKHBhcmFtcykgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHBhcmFtcy5hZHZhbmNlZEZyYXVkU2lnbmFscyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xufTtcblxudmFyIGxvYWRQYXJhbXM7XG52YXIgbG9hZFN0cmlwZUNhbGxlZCA9IGZhbHNlO1xudmFyIGxvYWRTdHJpcGUgPSBmdW5jdGlvbiBsb2FkU3RyaXBlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgbG9hZFN0cmlwZUNhbGxlZCA9IHRydWU7XG4gIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICByZXR1cm4gbG9hZFNjcmlwdChsb2FkUGFyYW1zKS50aGVuKGZ1bmN0aW9uIChtYXliZVN0cmlwZSkge1xuICAgIHJldHVybiBpbml0U3RyaXBlKG1heWJlU3RyaXBlLCBhcmdzLCBzdGFydFRpbWUpO1xuICB9KTtcbn07XG5cbmxvYWRTdHJpcGUuc2V0TG9hZFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIC8vIHdlIHdvbid0IHRocm93IGFuIGVycm9yIGlmIHNldExvYWRQYXJhbWV0ZXJzIGlzIGNhbGxlZCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyBiZWZvcmVcbiAgaWYgKGxvYWRTdHJpcGVDYWxsZWQgJiYgbG9hZFBhcmFtcykge1xuICAgIHZhciB2YWxpZGF0ZWRQYXJhbXMgPSB2YWxpZGF0ZUxvYWRQYXJhbXMocGFyYW1zKTtcbiAgICB2YXIgcGFyYW1ldGVyS2V5cyA9IE9iamVjdC5rZXlzKHZhbGlkYXRlZFBhcmFtcyk7XG4gICAgdmFyIHNhbWVQYXJhbWV0ZXJzID0gcGFyYW1ldGVyS2V5cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSkge1xuICAgICAgdmFyIF9sb2FkUGFyYW1zO1xuXG4gICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZSAmJiBwYXJhbXNbY3VycmVudFZhbHVlXSA9PT0gKChfbG9hZFBhcmFtcyA9IGxvYWRQYXJhbXMpID09PSBudWxsIHx8IF9sb2FkUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbG9hZFBhcmFtc1tjdXJyZW50VmFsdWVdKTtcbiAgICB9LCB0cnVlKTtcblxuICAgIGlmIChzYW1lUGFyYW1ldGVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsb2FkU3RyaXBlQ2FsbGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IGNoYW5nZSBsb2FkIHBhcmFtZXRlcnMgYWZ0ZXIgY2FsbGluZyBsb2FkU3RyaXBlJyk7XG4gIH1cblxuICBsb2FkUGFyYW1zID0gdmFsaWRhdGVMb2FkUGFyYW1zKHBhcmFtcyk7XG59O1xuXG5leHBvcnRzLmxvYWRTdHJpcGUgPSBsb2FkU3RyaXBlO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJWM19VUkwiLCJWM19VUkxfUkVHRVgiLCJFWElTVElOR19TQ1JJUFRfTUVTU0FHRSIsImZpbmRTY3JpcHQiLCJzY3JpcHRzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY29uY2F0IiwiaSIsImxlbmd0aCIsInNjcmlwdCIsInRlc3QiLCJzcmMiLCJpbmplY3RTY3JpcHQiLCJwYXJhbXMiLCJxdWVyeVN0cmluZyIsImFkdmFuY2VkRnJhdWRTaWduYWxzIiwiY3JlYXRlRWxlbWVudCIsImhlYWRPckJvZHkiLCJoZWFkIiwiYm9keSIsIkVycm9yIiwiYXBwZW5kQ2hpbGQiLCJyZWdpc3RlcldyYXBwZXIiLCJzdHJpcGUiLCJzdGFydFRpbWUiLCJfcmVnaXN0ZXJXcmFwcGVyIiwibmFtZSIsInZlcnNpb24iLCJzdHJpcGVQcm9taXNlIiwibG9hZFNjcmlwdCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwid2luZG93IiwiU3RyaXBlIiwiY29uc29sZSIsIndhcm4iLCJhZGRFdmVudExpc3RlbmVyIiwiZXJyb3IiLCJpbml0U3RyaXBlIiwibWF5YmVTdHJpcGUiLCJhcmdzIiwiYXBwbHkiLCJ1bmRlZmluZWQiLCJ2YWxpZGF0ZUxvYWRQYXJhbXMiLCJlcnJvck1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5Iiwia2V5cyIsImxvYWRQYXJhbXMiLCJsb2FkU3RyaXBlQ2FsbGVkIiwibG9hZFN0cmlwZSIsIl9sZW4iLCJhcmd1bWVudHMiLCJBcnJheSIsIl9rZXkiLCJEYXRlIiwibm93IiwidGhlbiIsInNldExvYWRQYXJhbWV0ZXJzIiwidmFsaWRhdGVkUGFyYW1zIiwicGFyYW1ldGVyS2V5cyIsInNhbWVQYXJhbWV0ZXJzIiwicmVkdWNlIiwicHJldmlvdXNWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsIl9sb2FkUGFyYW1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/dist/pure.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/stripe-js/pure.js":
/*!************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/pure.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ./dist/pure.js */ \"(ssr)/./node_modules/@stripe/stripe-js/dist/pure.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvcHVyZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLGlIQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3RyaXBlL3N0cmlwZS1qcy9wdXJlLmpzPzE0NmYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvcHVyZS5qcycpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/pure.js\n");

/***/ })

};
;